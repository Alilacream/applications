{"ast":null,"code":"'use strict';\n\nvar conventions = require('./conventions');\nvar g = require('./grammar');\nvar errors = require('./errors');\nvar isHTMLEscapableRawTextElement = conventions.isHTMLEscapableRawTextElement;\nvar isHTMLMimeType = conventions.isHTMLMimeType;\nvar isHTMLRawTextElement = conventions.isHTMLRawTextElement;\nvar hasOwn = conventions.hasOwn;\nvar NAMESPACE = conventions.NAMESPACE;\nvar ParseError = errors.ParseError;\nvar DOMException = errors.DOMException;\n\n//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')\n\n//S_TAG,\tS_ATTR,\tS_EQ,\tS_ATTR_NOQUOT_VALUE\n//S_ATTR_SPACE,\tS_ATTR_END,\tS_TAG_SPACE, S_TAG_CLOSE\nvar S_TAG = 0; //tag name offerring\nvar S_ATTR = 1; //attr name offerring\nvar S_ATTR_SPACE = 2; //attr name end and space offer\nvar S_EQ = 3; //=space?\nvar S_ATTR_NOQUOT_VALUE = 4; //attr value(no quot value only)\nvar S_ATTR_END = 5; //attr value end and no space(quot end)\nvar S_TAG_SPACE = 6; //(attr value end || tag end ) && (space offer)\nvar S_TAG_CLOSE = 7; //closed el<el />\n\nfunction XMLReader() {}\nXMLReader.prototype = {\n  parse: function (source, defaultNSMap, entityMap) {\n    var domBuilder = this.domBuilder;\n    domBuilder.startDocument();\n    _copy(defaultNSMap, defaultNSMap = Object.create(null));\n    parse(source, defaultNSMap, entityMap, domBuilder, this.errorHandler);\n    domBuilder.endDocument();\n  }\n};\n\n/**\n * Detecting everything that might be a reference,\n * including those without ending `;`, since those are allowed in HTML.\n * The entityReplacer takes care of verifying and transforming each occurrence,\n * and reports to the errorHandler on those that are not OK,\n * depending on the context.\n */\nvar ENTITY_REG = /&#?\\w+;?/g;\nfunction parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {\n  var isHTML = isHTMLMimeType(domBuilder.mimeType);\n  if (source.indexOf(g.UNICODE_REPLACEMENT_CHARACTER) >= 0) {\n    errorHandler.warning('Unicode replacement character detected, source encoding issues?');\n  }\n  function fixedFromCharCode(code) {\n    // String.prototype.fromCharCode does not supports\n    // > 2 bytes unicode chars directly\n    if (code > 0xffff) {\n      code -= 0x10000;\n      var surrogate1 = 0xd800 + (code >> 10),\n        surrogate2 = 0xdc00 + (code & 0x3ff);\n      return String.fromCharCode(surrogate1, surrogate2);\n    } else {\n      return String.fromCharCode(code);\n    }\n  }\n  function entityReplacer(a) {\n    var complete = a[a.length - 1] === ';' ? a : a + ';';\n    if (!isHTML && complete !== a) {\n      errorHandler.error('EntityRef: expecting ;');\n      return a;\n    }\n    var match = g.Reference.exec(complete);\n    if (!match || match[0].length !== complete.length) {\n      errorHandler.error('entity not matching Reference production: ' + a);\n      return a;\n    }\n    var k = complete.slice(1, -1);\n    if (hasOwn(entityMap, k)) {\n      return entityMap[k];\n    } else if (k.charAt(0) === '#') {\n      return fixedFromCharCode(parseInt(k.substring(1).replace('x', '0x')));\n    } else {\n      errorHandler.error('entity not found:' + a);\n      return a;\n    }\n  }\n  function appendText(end) {\n    //has some bugs\n    if (end > start) {\n      var xt = source.substring(start, end).replace(ENTITY_REG, entityReplacer);\n      locator && position(start);\n      domBuilder.characters(xt, 0, end - start);\n      start = end;\n    }\n  }\n  var lineStart = 0;\n  var lineEnd = 0;\n  var linePattern = /\\r\\n?|\\n|$/g;\n  var locator = domBuilder.locator;\n  function position(p, m) {\n    while (p >= lineEnd && (m = linePattern.exec(source))) {\n      lineStart = lineEnd;\n      lineEnd = m.index + m[0].length;\n      locator.lineNumber++;\n    }\n    locator.columnNumber = p - lineStart + 1;\n  }\n  var parseStack = [{\n    currentNSMap: defaultNSMapCopy\n  }];\n  var unclosedTags = [];\n  var start = 0;\n  while (true) {\n    try {\n      var tagStart = source.indexOf('<', start);\n      if (tagStart < 0) {\n        if (!isHTML && unclosedTags.length > 0) {\n          return errorHandler.fatalError('unclosed xml tag(s): ' + unclosedTags.join(', '));\n        }\n        if (!source.substring(start).match(/^\\s*$/)) {\n          var doc = domBuilder.doc;\n          var text = doc.createTextNode(source.substring(start));\n          if (doc.documentElement) {\n            return errorHandler.error('Extra content at the end of the document');\n          }\n          doc.appendChild(text);\n          domBuilder.currentElement = text;\n        }\n        return;\n      }\n      if (tagStart > start) {\n        var fromSource = source.substring(start, tagStart);\n        if (!isHTML && unclosedTags.length === 0) {\n          fromSource = fromSource.replace(new RegExp(g.S_OPT.source, 'g'), '');\n          fromSource && errorHandler.error(\"Unexpected content outside root element: '\" + fromSource + \"'\");\n        }\n        appendText(tagStart);\n      }\n      switch (source.charAt(tagStart + 1)) {\n        case '/':\n          var end = source.indexOf('>', tagStart + 2);\n          var tagNameRaw = source.substring(tagStart + 2, end > 0 ? end : undefined);\n          if (!tagNameRaw) {\n            return errorHandler.fatalError('end tag name missing');\n          }\n          var tagNameMatch = end > 0 && g.reg('^', g.QName_group, g.S_OPT, '$').exec(tagNameRaw);\n          if (!tagNameMatch) {\n            return errorHandler.fatalError('end tag name contains invalid characters: \"' + tagNameRaw + '\"');\n          }\n          if (!domBuilder.currentElement && !domBuilder.doc.documentElement) {\n            // not enough information to provide a helpful error message,\n            // but parsing will throw since there is no root element\n            return;\n          }\n          var currentTagName = unclosedTags[unclosedTags.length - 1] || domBuilder.currentElement.tagName || domBuilder.doc.documentElement.tagName || '';\n          if (currentTagName !== tagNameMatch[1]) {\n            var tagNameLower = tagNameMatch[1].toLowerCase();\n            if (!isHTML || currentTagName.toLowerCase() !== tagNameLower) {\n              return errorHandler.fatalError('Opening and ending tag mismatch: \"' + currentTagName + '\" != \"' + tagNameRaw + '\"');\n            }\n          }\n          var config = parseStack.pop();\n          unclosedTags.pop();\n          var localNSMap = config.localNSMap;\n          domBuilder.endElement(config.uri, config.localName, currentTagName);\n          if (localNSMap) {\n            for (var prefix in localNSMap) {\n              if (hasOwn(localNSMap, prefix)) {\n                domBuilder.endPrefixMapping(prefix);\n              }\n            }\n          }\n          end++;\n          break;\n        // end element\n        case '?':\n          // <?...?>\n          locator && position(tagStart);\n          end = parseProcessingInstruction(source, tagStart, domBuilder, errorHandler);\n          break;\n        case '!':\n          // <!doctype,<![CDATA,<!--\n          locator && position(tagStart);\n          end = parseDoctypeCommentOrCData(source, tagStart, domBuilder, errorHandler, isHTML);\n          break;\n        default:\n          locator && position(tagStart);\n          var el = new ElementAttributes();\n          var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;\n          //elStartEnd\n          var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler, isHTML);\n          var len = el.length;\n          if (!el.closed) {\n            if (isHTML && conventions.isHTMLVoidElement(el.tagName)) {\n              el.closed = true;\n            } else {\n              unclosedTags.push(el.tagName);\n            }\n          }\n          if (locator && len) {\n            var locator2 = copyLocator(locator, {});\n            //try{//attribute position fixed\n            for (var i = 0; i < len; i++) {\n              var a = el[i];\n              position(a.offset);\n              a.locator = copyLocator(locator, {});\n            }\n            domBuilder.locator = locator2;\n            if (appendElement(el, domBuilder, currentNSMap)) {\n              parseStack.push(el);\n            }\n            domBuilder.locator = locator;\n          } else {\n            if (appendElement(el, domBuilder, currentNSMap)) {\n              parseStack.push(el);\n            }\n          }\n          if (isHTML && !el.closed) {\n            end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);\n          } else {\n            end++;\n          }\n      }\n    } catch (e) {\n      if (e instanceof ParseError) {\n        throw e;\n      } else if (e instanceof DOMException) {\n        throw new ParseError(e.name + ': ' + e.message, domBuilder.locator, e);\n      }\n      errorHandler.error('element parse error: ' + e);\n      end = -1;\n    }\n    if (end > start) {\n      start = end;\n    } else {\n      //Possible sax fallback here, risk of positional error\n      appendText(Math.max(tagStart, start) + 1);\n    }\n  }\n}\nfunction copyLocator(f, t) {\n  t.lineNumber = f.lineNumber;\n  t.columnNumber = f.columnNumber;\n  return t;\n}\n\n/**\n * @returns\n * end of the elementStartPart(end of elementEndPart for selfClosed el)\n * @see {@link #appendElement}\n */\nfunction parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler, isHTML) {\n  /**\n   * @param {string} qname\n   * @param {string} value\n   * @param {number} startIndex\n   */\n  function addAttribute(qname, value, startIndex) {\n    if (hasOwn(el.attributeNames, qname)) {\n      return errorHandler.fatalError('Attribute ' + qname + ' redefined');\n    }\n    if (!isHTML && value.indexOf('<') >= 0) {\n      return errorHandler.fatalError(\"Unescaped '<' not allowed in attributes values\");\n    }\n    el.addValue(qname,\n    // @see https://www.w3.org/TR/xml/#AVNormalize\n    // since the xmldom sax parser does not \"interpret\" DTD the following is not implemented:\n    // - recursive replacement of (DTD) entity references\n    // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA\n    value.replace(/[\\t\\n\\r]/g, ' ').replace(ENTITY_REG, entityReplacer), startIndex);\n  }\n  var attrName;\n  var value;\n  var p = ++start;\n  var s = S_TAG; //status\n  while (true) {\n    var c = source.charAt(p);\n    switch (c) {\n      case '=':\n        if (s === S_ATTR) {\n          //attrName\n          attrName = source.slice(start, p);\n          s = S_EQ;\n        } else if (s === S_ATTR_SPACE) {\n          s = S_EQ;\n        } else {\n          //fatalError: equal must after attrName or space after attrName\n          throw new Error('attribute equal must after attrName'); // No known test case\n        }\n        break;\n      case \"'\":\n      case '\"':\n        if (s === S_EQ || s === S_ATTR //|| s == S_ATTR_SPACE\n        ) {\n          //equal\n          if (s === S_ATTR) {\n            errorHandler.warning('attribute value must after \"=\"');\n            attrName = source.slice(start, p);\n          }\n          start = p + 1;\n          p = source.indexOf(c, start);\n          if (p > 0) {\n            value = source.slice(start, p);\n            addAttribute(attrName, value, start - 1);\n            s = S_ATTR_END;\n          } else {\n            //fatalError: no end quot match\n            throw new Error(\"attribute value no end '\" + c + \"' match\");\n          }\n        } else if (s == S_ATTR_NOQUOT_VALUE) {\n          value = source.slice(start, p);\n          addAttribute(attrName, value, start);\n          errorHandler.warning('attribute \"' + attrName + '\" missed start quot(' + c + ')!!');\n          start = p + 1;\n          s = S_ATTR_END;\n        } else {\n          //fatalError: no equal before\n          throw new Error('attribute value must after \"=\"'); // No known test case\n        }\n        break;\n      case '/':\n        switch (s) {\n          case S_TAG:\n            el.setTagName(source.slice(start, p));\n          case S_ATTR_END:\n          case S_TAG_SPACE:\n          case S_TAG_CLOSE:\n            s = S_TAG_CLOSE;\n            el.closed = true;\n          case S_ATTR_NOQUOT_VALUE:\n          case S_ATTR:\n            break;\n          case S_ATTR_SPACE:\n            el.closed = true;\n            break;\n          //case S_EQ:\n          default:\n            throw new Error(\"attribute invalid close char('/')\");\n          // No known test case\n        }\n        break;\n      case '':\n        //end document\n        errorHandler.error('unexpected end of input');\n        if (s == S_TAG) {\n          el.setTagName(source.slice(start, p));\n        }\n        return p;\n      case '>':\n        switch (s) {\n          case S_TAG:\n            el.setTagName(source.slice(start, p));\n          case S_ATTR_END:\n          case S_TAG_SPACE:\n          case S_TAG_CLOSE:\n            break;\n          //normal\n          case S_ATTR_NOQUOT_VALUE: //Compatible state\n          case S_ATTR:\n            value = source.slice(start, p);\n            if (value.slice(-1) === '/') {\n              el.closed = true;\n              value = value.slice(0, -1);\n            }\n          case S_ATTR_SPACE:\n            if (s === S_ATTR_SPACE) {\n              value = attrName;\n            }\n            if (s == S_ATTR_NOQUOT_VALUE) {\n              errorHandler.warning('attribute \"' + value + '\" missed quot(\")!');\n              addAttribute(attrName, value, start);\n            } else {\n              if (!isHTML) {\n                errorHandler.warning('attribute \"' + value + '\" missed value!! \"' + value + '\" instead!!');\n              }\n              addAttribute(value, value, start);\n            }\n            break;\n          case S_EQ:\n            if (!isHTML) {\n              return errorHandler.fatalError('AttValue: \\' or \" expected');\n            }\n        }\n        return p;\n      /*xml space '\\x20' | #x9 | #xD | #xA; */\n      case '\\u0080':\n        c = ' ';\n      default:\n        if (c <= ' ') {\n          //space\n          switch (s) {\n            case S_TAG:\n              el.setTagName(source.slice(start, p)); //tagName\n              s = S_TAG_SPACE;\n              break;\n            case S_ATTR:\n              attrName = source.slice(start, p);\n              s = S_ATTR_SPACE;\n              break;\n            case S_ATTR_NOQUOT_VALUE:\n              var value = source.slice(start, p);\n              errorHandler.warning('attribute \"' + value + '\" missed quot(\")!!');\n              addAttribute(attrName, value, start);\n            case S_ATTR_END:\n              s = S_TAG_SPACE;\n              break;\n            //case S_TAG_SPACE:\n            //case S_EQ:\n            //case S_ATTR_SPACE:\n            //\tvoid();break;\n            //case S_TAG_CLOSE:\n            //ignore warning\n          }\n        } else {\n          //not space\n          //S_TAG,\tS_ATTR,\tS_EQ,\tS_ATTR_NOQUOT_VALUE\n          //S_ATTR_SPACE,\tS_ATTR_END,\tS_TAG_SPACE, S_TAG_CLOSE\n          switch (s) {\n            //case S_TAG:void();break;\n            //case S_ATTR:void();break;\n            //case S_ATTR_NOQUOT_VALUE:void();break;\n            case S_ATTR_SPACE:\n              if (!isHTML) {\n                errorHandler.warning('attribute \"' + attrName + '\" missed value!! \"' + attrName + '\" instead2!!');\n              }\n              addAttribute(attrName, attrName, start);\n              start = p;\n              s = S_ATTR;\n              break;\n            case S_ATTR_END:\n              errorHandler.warning('attribute space is required\"' + attrName + '\"!!');\n            case S_TAG_SPACE:\n              s = S_ATTR;\n              start = p;\n              break;\n            case S_EQ:\n              s = S_ATTR_NOQUOT_VALUE;\n              start = p;\n              break;\n            case S_TAG_CLOSE:\n              throw new Error(\"elements closed character '/' and '>' must be connected to\");\n          }\n        }\n    } //end outer switch\n    p++;\n  }\n}\n\n/**\n * @returns\n * `true` if a new namespace has been defined.\n */\nfunction appendElement(el, domBuilder, currentNSMap) {\n  var tagName = el.tagName;\n  var localNSMap = null;\n  var i = el.length;\n  while (i--) {\n    var a = el[i];\n    var qName = a.qName;\n    var value = a.value;\n    var nsp = qName.indexOf(':');\n    if (nsp > 0) {\n      var prefix = a.prefix = qName.slice(0, nsp);\n      var localName = qName.slice(nsp + 1);\n      var nsPrefix = prefix === 'xmlns' && localName;\n    } else {\n      localName = qName;\n      prefix = null;\n      nsPrefix = qName === 'xmlns' && '';\n    }\n    //can not set prefix,because prefix !== ''\n    a.localName = localName;\n    //prefix == null for no ns prefix attribute\n    if (nsPrefix !== false) {\n      //hack!!\n      if (localNSMap == null) {\n        localNSMap = Object.create(null);\n        _copy(currentNSMap, currentNSMap = Object.create(null));\n      }\n      currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;\n      a.uri = NAMESPACE.XMLNS;\n      domBuilder.startPrefixMapping(nsPrefix, value);\n    }\n  }\n  var i = el.length;\n  while (i--) {\n    a = el[i];\n    if (a.prefix) {\n      //no prefix attribute has no namespace\n      if (a.prefix === 'xml') {\n        a.uri = NAMESPACE.XML;\n      }\n      if (a.prefix !== 'xmlns') {\n        a.uri = currentNSMap[a.prefix];\n      }\n    }\n  }\n  var nsp = tagName.indexOf(':');\n  if (nsp > 0) {\n    prefix = el.prefix = tagName.slice(0, nsp);\n    localName = el.localName = tagName.slice(nsp + 1);\n  } else {\n    prefix = null; //important!!\n    localName = el.localName = tagName;\n  }\n  //no prefix element has default namespace\n  var ns = el.uri = currentNSMap[prefix || ''];\n  domBuilder.startElement(ns, localName, tagName, el);\n  //endPrefixMapping and startPrefixMapping have not any help for dom builder\n  //localNSMap = null\n  if (el.closed) {\n    domBuilder.endElement(ns, localName, tagName);\n    if (localNSMap) {\n      for (prefix in localNSMap) {\n        if (hasOwn(localNSMap, prefix)) {\n          domBuilder.endPrefixMapping(prefix);\n        }\n      }\n    }\n  } else {\n    el.currentNSMap = currentNSMap;\n    el.localNSMap = localNSMap;\n    //parseStack.push(el);\n    return true;\n  }\n}\nfunction parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {\n  // https://html.spec.whatwg.org/#raw-text-elements\n  // https://html.spec.whatwg.org/#escapable-raw-text-elements\n  // https://html.spec.whatwg.org/#cdata-rcdata-restrictions:raw-text-elements\n  // TODO: https://html.spec.whatwg.org/#cdata-rcdata-restrictions\n  var isEscapableRaw = isHTMLEscapableRawTextElement(tagName);\n  if (isEscapableRaw || isHTMLRawTextElement(tagName)) {\n    var elEndStart = source.indexOf('</' + tagName + '>', elStartEnd);\n    var text = source.substring(elStartEnd + 1, elEndStart);\n    if (isEscapableRaw) {\n      text = text.replace(ENTITY_REG, entityReplacer);\n    }\n    domBuilder.characters(text, 0, text.length);\n    return elEndStart;\n  }\n  return elStartEnd + 1;\n}\nfunction _copy(source, target) {\n  for (var n in source) {\n    if (hasOwn(source, n)) {\n      target[n] = source[n];\n    }\n  }\n}\n\n/**\n * @typedef ParseUtils\n * @property {function(relativeIndex: number?): string | undefined} char\n * Provides look ahead access to a singe character relative to the current index.\n * @property {function(): number} getIndex\n * Provides read-only access to the current index.\n * @property {function(reg: RegExp): string | null} getMatch\n * Applies the provided regular expression enforcing that it starts at the current index and\n * returns the complete matching string,\n * and moves the current index by the length of the matching string.\n * @property {function(): string} getSource\n * Provides read-only access to the complete source.\n * @property {function(places: number?): void} skip\n * moves the current index by places (defaults to 1)\n * @property {function(): number} skipBlanks\n * Moves the current index by the amount of white space that directly follows the current index\n * and returns the amount of whitespace chars skipped (0..n),\n * or -1 if the end of the source was reached.\n * @property {function(): string} substringFromIndex\n * creates a substring from the current index to the end of `source`\n * @property {function(compareWith: string): boolean} substringStartsWith\n * Checks if `source` contains `compareWith`, starting from the current index.\n * @property {function(compareWith: string): boolean} substringStartsWithCaseInsensitive\n * Checks if `source` contains `compareWith`, starting from the current index,\n * comparing the upper case of both sides.\n * @see {@link parseUtils}\n */\n\n/**\n * A temporary scope for parsing and look ahead operations in `source`,\n * starting from index `start`.\n *\n * Some operations move the current index by a number of positions,\n * after which `getIndex` returns the new index.\n *\n * @param {string} source\n * @param {number} start\n * @returns {ParseUtils}\n */\nfunction parseUtils(source, start) {\n  var index = start;\n  function char(n) {\n    n = n || 0;\n    return source.charAt(index + n);\n  }\n  function skip(n) {\n    n = n || 1;\n    index += n;\n  }\n  function skipBlanks() {\n    var blanks = 0;\n    while (index < source.length) {\n      var c = char();\n      if (c !== ' ' && c !== '\\n' && c !== '\\t' && c !== '\\r') {\n        return blanks;\n      }\n      blanks++;\n      skip();\n    }\n    return -1;\n  }\n  function substringFromIndex() {\n    return source.substring(index);\n  }\n  function substringStartsWith(text) {\n    return source.substring(index, index + text.length) === text;\n  }\n  function substringStartsWithCaseInsensitive(text) {\n    return source.substring(index, index + text.length).toUpperCase() === text.toUpperCase();\n  }\n  function getMatch(args) {\n    var expr = g.reg('^', args);\n    var match = expr.exec(substringFromIndex());\n    if (match) {\n      skip(match[0].length);\n      return match[0];\n    }\n    return null;\n  }\n  return {\n    char: char,\n    getIndex: function () {\n      return index;\n    },\n    getMatch: getMatch,\n    getSource: function () {\n      return source;\n    },\n    skip: skip,\n    skipBlanks: skipBlanks,\n    substringFromIndex: substringFromIndex,\n    substringStartsWith: substringStartsWith,\n    substringStartsWithCaseInsensitive: substringStartsWithCaseInsensitive\n  };\n}\n\n/**\n * @param {ParseUtils} p\n * @param {DOMHandler} errorHandler\n * @returns {string}\n */\nfunction parseDoctypeInternalSubset(p, errorHandler) {\n  /**\n   * @param {ParseUtils} p\n   * @param {DOMHandler} errorHandler\n   * @returns {string}\n   */\n  function parsePI(p, errorHandler) {\n    var match = g.PI.exec(p.substringFromIndex());\n    if (!match) {\n      return errorHandler.fatalError('processing instruction is not well-formed at position ' + p.getIndex());\n    }\n    if (match[1].toLowerCase() === 'xml') {\n      return errorHandler.fatalError('xml declaration is only allowed at the start of the document, but found at position ' + p.getIndex());\n    }\n    p.skip(match[0].length);\n    return match[0];\n  }\n  // Parse internal subset\n  var source = p.getSource();\n  if (p.char() === '[') {\n    p.skip(1);\n    var intSubsetStart = p.getIndex();\n    while (p.getIndex() < source.length) {\n      p.skipBlanks();\n      if (p.char() === ']') {\n        var internalSubset = source.substring(intSubsetStart, p.getIndex());\n        p.skip(1);\n        return internalSubset;\n      }\n      var current = null;\n      // Only in external subset\n      // if (char() === '<' && char(1) === '!' && char(2) === '[') {\n      // \tparseConditionalSections(p, errorHandler);\n      // } else\n      if (p.char() === '<' && p.char(1) === '!') {\n        switch (p.char(2)) {\n          case 'E':\n            // ELEMENT | ENTITY\n            if (p.char(3) === 'L') {\n              current = p.getMatch(g.elementdecl);\n            } else if (p.char(3) === 'N') {\n              current = p.getMatch(g.EntityDecl);\n            }\n            break;\n          case 'A':\n            // ATTRIBUTE\n            current = p.getMatch(g.AttlistDecl);\n            break;\n          case 'N':\n            // NOTATION\n            current = p.getMatch(g.NotationDecl);\n            break;\n          case '-':\n            // COMMENT\n            current = p.getMatch(g.Comment);\n            break;\n        }\n      } else if (p.char() === '<' && p.char(1) === '?') {\n        current = parsePI(p, errorHandler);\n      } else if (p.char() === '%') {\n        current = p.getMatch(g.PEReference);\n      } else {\n        return errorHandler.fatalError('Error detected in Markup declaration');\n      }\n      if (!current) {\n        return errorHandler.fatalError('Error in internal subset at position ' + p.getIndex());\n      }\n    }\n    return errorHandler.fatalError('doctype internal subset is not well-formed, missing ]');\n  }\n}\n\n/**\n * Called when the parser encounters an element starting with '<!'.\n *\n * @param {string} source\n * The xml.\n * @param {number} start\n * the start index of the '<!'\n * @param {DOMHandler} domBuilder\n * @param {DOMHandler} errorHandler\n * @param {boolean} isHTML\n * @returns {number | never}\n * The end index of the element.\n * @throws {ParseError}\n * In case the element is not well-formed.\n */\nfunction parseDoctypeCommentOrCData(source, start, domBuilder, errorHandler, isHTML) {\n  var p = parseUtils(source, start);\n  switch (isHTML ? p.char(2).toUpperCase() : p.char(2)) {\n    case '-':\n      // should be a comment\n      var comment = p.getMatch(g.Comment);\n      if (comment) {\n        domBuilder.comment(comment, g.COMMENT_START.length, comment.length - g.COMMENT_START.length - g.COMMENT_END.length);\n        return p.getIndex();\n      } else {\n        return errorHandler.fatalError('comment is not well-formed at position ' + p.getIndex());\n      }\n    case '[':\n      // should be CDATA\n      var cdata = p.getMatch(g.CDSect);\n      if (cdata) {\n        if (!isHTML && !domBuilder.currentElement) {\n          return errorHandler.fatalError('CDATA outside of element');\n        }\n        domBuilder.startCDATA();\n        domBuilder.characters(cdata, g.CDATA_START.length, cdata.length - g.CDATA_START.length - g.CDATA_END.length);\n        domBuilder.endCDATA();\n        return p.getIndex();\n      } else {\n        return errorHandler.fatalError('Invalid CDATA starting at position ' + start);\n      }\n    case 'D':\n      {\n        // should be DOCTYPE\n        if (domBuilder.doc && domBuilder.doc.documentElement) {\n          return errorHandler.fatalError('Doctype not allowed inside or after documentElement at position ' + p.getIndex());\n        }\n        if (isHTML ? !p.substringStartsWithCaseInsensitive(g.DOCTYPE_DECL_START) : !p.substringStartsWith(g.DOCTYPE_DECL_START)) {\n          return errorHandler.fatalError('Expected ' + g.DOCTYPE_DECL_START + ' at position ' + p.getIndex());\n        }\n        p.skip(g.DOCTYPE_DECL_START.length);\n        if (p.skipBlanks() < 1) {\n          return errorHandler.fatalError('Expected whitespace after ' + g.DOCTYPE_DECL_START + ' at position ' + p.getIndex());\n        }\n        var doctype = {\n          name: undefined,\n          publicId: undefined,\n          systemId: undefined,\n          internalSubset: undefined\n        };\n        // Parse the DOCTYPE name\n        doctype.name = p.getMatch(g.Name);\n        if (!doctype.name) return errorHandler.fatalError('doctype name missing or contains unexpected characters at position ' + p.getIndex());\n        if (isHTML && doctype.name.toLowerCase() !== 'html') {\n          errorHandler.warning('Unexpected DOCTYPE in HTML document at position ' + p.getIndex());\n        }\n        p.skipBlanks();\n\n        // Check for ExternalID\n        if (p.substringStartsWith(g.PUBLIC) || p.substringStartsWith(g.SYSTEM)) {\n          var match = g.ExternalID_match.exec(p.substringFromIndex());\n          if (!match) {\n            return errorHandler.fatalError('doctype external id is not well-formed at position ' + p.getIndex());\n          }\n          if (match.groups.SystemLiteralOnly !== undefined) {\n            doctype.systemId = match.groups.SystemLiteralOnly;\n          } else {\n            doctype.systemId = match.groups.SystemLiteral;\n            doctype.publicId = match.groups.PubidLiteral;\n          }\n          p.skip(match[0].length);\n        } else if (isHTML && p.substringStartsWithCaseInsensitive(g.SYSTEM)) {\n          // https://html.spec.whatwg.org/multipage/syntax.html#doctype-legacy-string\n          p.skip(g.SYSTEM.length);\n          if (p.skipBlanks() < 1) {\n            return errorHandler.fatalError('Expected whitespace after ' + g.SYSTEM + ' at position ' + p.getIndex());\n          }\n          doctype.systemId = p.getMatch(g.ABOUT_LEGACY_COMPAT_SystemLiteral);\n          if (!doctype.systemId) {\n            return errorHandler.fatalError('Expected ' + g.ABOUT_LEGACY_COMPAT + ' in single or double quotes after ' + g.SYSTEM + ' at position ' + p.getIndex());\n          }\n        }\n        if (isHTML && doctype.systemId && !g.ABOUT_LEGACY_COMPAT_SystemLiteral.test(doctype.systemId)) {\n          errorHandler.warning('Unexpected doctype.systemId in HTML document at position ' + p.getIndex());\n        }\n        if (!isHTML) {\n          p.skipBlanks();\n          doctype.internalSubset = parseDoctypeInternalSubset(p, errorHandler);\n        }\n        p.skipBlanks();\n        if (p.char() !== '>') {\n          return errorHandler.fatalError('doctype not terminated with > at position ' + p.getIndex());\n        }\n        p.skip(1);\n        domBuilder.startDTD(doctype.name, doctype.publicId, doctype.systemId, doctype.internalSubset);\n        domBuilder.endDTD();\n        return p.getIndex();\n      }\n    default:\n      return errorHandler.fatalError('Not well-formed XML starting with \"<!\" at position ' + start);\n  }\n}\nfunction parseProcessingInstruction(source, start, domBuilder, errorHandler) {\n  var match = source.substring(start).match(g.PI);\n  if (!match) {\n    return errorHandler.fatalError('Invalid processing instruction starting at position ' + start);\n  }\n  if (match[1].toLowerCase() === 'xml') {\n    if (start > 0) {\n      return errorHandler.fatalError('processing instruction at position ' + start + ' is an xml declaration which is only at the start of the document');\n    }\n    if (!g.XMLDecl.test(source.substring(start))) {\n      return errorHandler.fatalError('xml declaration is not well-formed');\n    }\n  }\n  domBuilder.processingInstruction(match[1], match[2]);\n  return start + match[0].length;\n}\nfunction ElementAttributes() {\n  this.attributeNames = Object.create(null);\n}\nElementAttributes.prototype = {\n  setTagName: function (tagName) {\n    if (!g.QName_exact.test(tagName)) {\n      throw new Error('invalid tagName:' + tagName);\n    }\n    this.tagName = tagName;\n  },\n  addValue: function (qName, value, offset) {\n    if (!g.QName_exact.test(qName)) {\n      throw new Error('invalid attribute:' + qName);\n    }\n    this.attributeNames[qName] = this.length;\n    this[this.length++] = {\n      qName: qName,\n      value: value,\n      offset: offset\n    };\n  },\n  length: 0,\n  getLocalName: function (i) {\n    return this[i].localName;\n  },\n  getLocator: function (i) {\n    return this[i].locator;\n  },\n  getQName: function (i) {\n    return this[i].qName;\n  },\n  getURI: function (i) {\n    return this[i].uri;\n  },\n  getValue: function (i) {\n    return this[i].value;\n  }\n  //\t,getIndex:function(uri, localName)){\n  //\t\tif(localName){\n  //\n  //\t\t}else{\n  //\t\t\tvar qName = uri\n  //\t\t}\n  //\t},\n  //\tgetValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},\n  //\tgetType:function(uri,localName){}\n  //\tgetType:function(i){},\n};\nexports.XMLReader = XMLReader;\nexports.parseUtils = parseUtils;\nexports.parseDoctypeCommentOrCData = parseDoctypeCommentOrCData;","map":{"version":3,"names":["conventions","require","g","errors","isHTMLEscapableRawTextElement","isHTMLMimeType","isHTMLRawTextElement","hasOwn","NAMESPACE","ParseError","DOMException","S_TAG","S_ATTR","S_ATTR_SPACE","S_EQ","S_ATTR_NOQUOT_VALUE","S_ATTR_END","S_TAG_SPACE","S_TAG_CLOSE","XMLReader","prototype","parse","source","defaultNSMap","entityMap","domBuilder","startDocument","_copy","Object","create","errorHandler","endDocument","ENTITY_REG","defaultNSMapCopy","isHTML","mimeType","indexOf","UNICODE_REPLACEMENT_CHARACTER","warning","fixedFromCharCode","code","surrogate1","surrogate2","String","fromCharCode","entityReplacer","a","complete","length","error","match","Reference","exec","k","slice","charAt","parseInt","substring","replace","appendText","end","start","xt","locator","position","characters","lineStart","lineEnd","linePattern","p","m","index","lineNumber","columnNumber","parseStack","currentNSMap","unclosedTags","tagStart","fatalError","join","doc","text","createTextNode","documentElement","appendChild","currentElement","fromSource","RegExp","S_OPT","tagNameRaw","undefined","tagNameMatch","reg","QName_group","currentTagName","tagName","tagNameLower","toLowerCase","config","pop","localNSMap","endElement","uri","localName","prefix","endPrefixMapping","parseProcessingInstruction","parseDoctypeCommentOrCData","el","ElementAttributes","parseElementStartPart","len","closed","isHTMLVoidElement","push","locator2","copyLocator","i","offset","appendElement","parseHtmlSpecialContent","e","name","message","Math","max","f","t","addAttribute","qname","value","startIndex","attributeNames","addValue","attrName","s","c","Error","setTagName","qName","nsp","nsPrefix","XMLNS","startPrefixMapping","XML","ns","startElement","elStartEnd","isEscapableRaw","elEndStart","target","n","parseUtils","char","skip","skipBlanks","blanks","substringFromIndex","substringStartsWith","substringStartsWithCaseInsensitive","toUpperCase","getMatch","args","expr","getIndex","getSource","parseDoctypeInternalSubset","parsePI","PI","intSubsetStart","internalSubset","current","elementdecl","EntityDecl","AttlistDecl","NotationDecl","Comment","PEReference","comment","COMMENT_START","COMMENT_END","cdata","CDSect","startCDATA","CDATA_START","CDATA_END","endCDATA","DOCTYPE_DECL_START","doctype","publicId","systemId","Name","PUBLIC","SYSTEM","ExternalID_match","groups","SystemLiteralOnly","SystemLiteral","PubidLiteral","ABOUT_LEGACY_COMPAT_SystemLiteral","ABOUT_LEGACY_COMPAT","test","startDTD","endDTD","XMLDecl","processingInstruction","QName_exact","getLocalName","getLocator","getQName","getURI","getValue","exports"],"sources":["/home/ali/Desktop/applications/node_modules/@xmldom/xmldom/lib/sax.js"],"sourcesContent":["'use strict';\n\nvar conventions = require('./conventions');\nvar g = require('./grammar');\nvar errors = require('./errors');\n\nvar isHTMLEscapableRawTextElement = conventions.isHTMLEscapableRawTextElement;\nvar isHTMLMimeType = conventions.isHTMLMimeType;\nvar isHTMLRawTextElement = conventions.isHTMLRawTextElement;\nvar hasOwn = conventions.hasOwn;\nvar NAMESPACE = conventions.NAMESPACE;\nvar ParseError = errors.ParseError;\nvar DOMException = errors.DOMException;\n\n//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')\n\n//S_TAG,\tS_ATTR,\tS_EQ,\tS_ATTR_NOQUOT_VALUE\n//S_ATTR_SPACE,\tS_ATTR_END,\tS_TAG_SPACE, S_TAG_CLOSE\nvar S_TAG = 0; //tag name offerring\nvar S_ATTR = 1; //attr name offerring\nvar S_ATTR_SPACE = 2; //attr name end and space offer\nvar S_EQ = 3; //=space?\nvar S_ATTR_NOQUOT_VALUE = 4; //attr value(no quot value only)\nvar S_ATTR_END = 5; //attr value end and no space(quot end)\nvar S_TAG_SPACE = 6; //(attr value end || tag end ) && (space offer)\nvar S_TAG_CLOSE = 7; //closed el<el />\n\nfunction XMLReader() {}\n\nXMLReader.prototype = {\n\tparse: function (source, defaultNSMap, entityMap) {\n\t\tvar domBuilder = this.domBuilder;\n\t\tdomBuilder.startDocument();\n\t\t_copy(defaultNSMap, (defaultNSMap = Object.create(null)));\n\t\tparse(source, defaultNSMap, entityMap, domBuilder, this.errorHandler);\n\t\tdomBuilder.endDocument();\n\t},\n};\n\n/**\n * Detecting everything that might be a reference,\n * including those without ending `;`, since those are allowed in HTML.\n * The entityReplacer takes care of verifying and transforming each occurrence,\n * and reports to the errorHandler on those that are not OK,\n * depending on the context.\n */\nvar ENTITY_REG = /&#?\\w+;?/g;\n\nfunction parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {\n\tvar isHTML = isHTMLMimeType(domBuilder.mimeType);\n\tif (source.indexOf(g.UNICODE_REPLACEMENT_CHARACTER) >= 0) {\n\t\terrorHandler.warning('Unicode replacement character detected, source encoding issues?');\n\t}\n\n\tfunction fixedFromCharCode(code) {\n\t\t// String.prototype.fromCharCode does not supports\n\t\t// > 2 bytes unicode chars directly\n\t\tif (code > 0xffff) {\n\t\t\tcode -= 0x10000;\n\t\t\tvar surrogate1 = 0xd800 + (code >> 10),\n\t\t\t\tsurrogate2 = 0xdc00 + (code & 0x3ff);\n\n\t\t\treturn String.fromCharCode(surrogate1, surrogate2);\n\t\t} else {\n\t\t\treturn String.fromCharCode(code);\n\t\t}\n\t}\n\n\tfunction entityReplacer(a) {\n\t\tvar complete = a[a.length - 1] === ';' ? a : a + ';';\n\t\tif (!isHTML && complete !== a) {\n\t\t\terrorHandler.error('EntityRef: expecting ;');\n\t\t\treturn a;\n\t\t}\n\t\tvar match = g.Reference.exec(complete);\n\t\tif (!match || match[0].length !== complete.length) {\n\t\t\terrorHandler.error('entity not matching Reference production: ' + a);\n\t\t\treturn a;\n\t\t}\n\t\tvar k = complete.slice(1, -1);\n\t\tif (hasOwn(entityMap, k)) {\n\t\t\treturn entityMap[k];\n\t\t} else if (k.charAt(0) === '#') {\n\t\t\treturn fixedFromCharCode(parseInt(k.substring(1).replace('x', '0x')));\n\t\t} else {\n\t\t\terrorHandler.error('entity not found:' + a);\n\t\t\treturn a;\n\t\t}\n\t}\n\n\tfunction appendText(end) {\n\t\t//has some bugs\n\t\tif (end > start) {\n\t\t\tvar xt = source.substring(start, end).replace(ENTITY_REG, entityReplacer);\n\t\t\tlocator && position(start);\n\t\t\tdomBuilder.characters(xt, 0, end - start);\n\t\t\tstart = end;\n\t\t}\n\t}\n\n\tvar lineStart = 0;\n\tvar lineEnd = 0;\n\tvar linePattern = /\\r\\n?|\\n|$/g;\n\tvar locator = domBuilder.locator;\n\n\tfunction position(p, m) {\n\t\twhile (p >= lineEnd && (m = linePattern.exec(source))) {\n\t\t\tlineStart = lineEnd;\n\t\t\tlineEnd = m.index + m[0].length;\n\t\t\tlocator.lineNumber++;\n\t\t}\n\t\tlocator.columnNumber = p - lineStart + 1;\n\t}\n\n\tvar parseStack = [{ currentNSMap: defaultNSMapCopy }];\n\tvar unclosedTags = [];\n\tvar start = 0;\n\twhile (true) {\n\t\ttry {\n\t\t\tvar tagStart = source.indexOf('<', start);\n\t\t\tif (tagStart < 0) {\n\t\t\t\tif (!isHTML && unclosedTags.length > 0) {\n\t\t\t\t\treturn errorHandler.fatalError('unclosed xml tag(s): ' + unclosedTags.join(', '));\n\t\t\t\t}\n\t\t\t\tif (!source.substring(start).match(/^\\s*$/)) {\n\t\t\t\t\tvar doc = domBuilder.doc;\n\t\t\t\t\tvar text = doc.createTextNode(source.substring(start));\n\t\t\t\t\tif (doc.documentElement) {\n\t\t\t\t\t\treturn errorHandler.error('Extra content at the end of the document');\n\t\t\t\t\t}\n\t\t\t\t\tdoc.appendChild(text);\n\t\t\t\t\tdomBuilder.currentElement = text;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (tagStart > start) {\n\t\t\t\tvar fromSource = source.substring(start, tagStart);\n\t\t\t\tif (!isHTML && unclosedTags.length === 0) {\n\t\t\t\t\tfromSource = fromSource.replace(new RegExp(g.S_OPT.source, 'g'), '');\n\t\t\t\t\tfromSource && errorHandler.error(\"Unexpected content outside root element: '\" + fromSource + \"'\");\n\t\t\t\t}\n\t\t\t\tappendText(tagStart);\n\t\t\t}\n\t\t\tswitch (source.charAt(tagStart + 1)) {\n\t\t\t\tcase '/':\n\t\t\t\t\tvar end = source.indexOf('>', tagStart + 2);\n\t\t\t\t\tvar tagNameRaw = source.substring(tagStart + 2, end > 0 ? end : undefined);\n\t\t\t\t\tif (!tagNameRaw) {\n\t\t\t\t\t\treturn errorHandler.fatalError('end tag name missing');\n\t\t\t\t\t}\n\t\t\t\t\tvar tagNameMatch = end > 0 && g.reg('^', g.QName_group, g.S_OPT, '$').exec(tagNameRaw);\n\t\t\t\t\tif (!tagNameMatch) {\n\t\t\t\t\t\treturn errorHandler.fatalError('end tag name contains invalid characters: \"' + tagNameRaw + '\"');\n\t\t\t\t\t}\n\t\t\t\t\tif (!domBuilder.currentElement && !domBuilder.doc.documentElement) {\n\t\t\t\t\t\t// not enough information to provide a helpful error message,\n\t\t\t\t\t\t// but parsing will throw since there is no root element\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tvar currentTagName =\n\t\t\t\t\t\tunclosedTags[unclosedTags.length - 1] ||\n\t\t\t\t\t\tdomBuilder.currentElement.tagName ||\n\t\t\t\t\t\tdomBuilder.doc.documentElement.tagName ||\n\t\t\t\t\t\t'';\n\t\t\t\t\tif (currentTagName !== tagNameMatch[1]) {\n\t\t\t\t\t\tvar tagNameLower = tagNameMatch[1].toLowerCase();\n\t\t\t\t\t\tif (!isHTML || currentTagName.toLowerCase() !== tagNameLower) {\n\t\t\t\t\t\t\treturn errorHandler.fatalError('Opening and ending tag mismatch: \"' + currentTagName + '\" != \"' + tagNameRaw + '\"');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar config = parseStack.pop();\n\t\t\t\t\tunclosedTags.pop();\n\t\t\t\t\tvar localNSMap = config.localNSMap;\n\t\t\t\t\tdomBuilder.endElement(config.uri, config.localName, currentTagName);\n\t\t\t\t\tif (localNSMap) {\n\t\t\t\t\t\tfor (var prefix in localNSMap) {\n\t\t\t\t\t\t\tif (hasOwn(localNSMap, prefix)) {\n\t\t\t\t\t\t\t\tdomBuilder.endPrefixMapping(prefix);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tend++;\n\t\t\t\t\tbreak;\n\t\t\t\t// end element\n\t\t\t\tcase '?': // <?...?>\n\t\t\t\t\tlocator && position(tagStart);\n\t\t\t\t\tend = parseProcessingInstruction(source, tagStart, domBuilder, errorHandler);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '!': // <!doctype,<![CDATA,<!--\n\t\t\t\t\tlocator && position(tagStart);\n\t\t\t\t\tend = parseDoctypeCommentOrCData(source, tagStart, domBuilder, errorHandler, isHTML);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlocator && position(tagStart);\n\t\t\t\t\tvar el = new ElementAttributes();\n\t\t\t\t\tvar currentNSMap = parseStack[parseStack.length - 1].currentNSMap;\n\t\t\t\t\t//elStartEnd\n\t\t\t\t\tvar end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler, isHTML);\n\t\t\t\t\tvar len = el.length;\n\n\t\t\t\t\tif (!el.closed) {\n\t\t\t\t\t\tif (isHTML && conventions.isHTMLVoidElement(el.tagName)) {\n\t\t\t\t\t\t\tel.closed = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tunclosedTags.push(el.tagName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (locator && len) {\n\t\t\t\t\t\tvar locator2 = copyLocator(locator, {});\n\t\t\t\t\t\t//try{//attribute position fixed\n\t\t\t\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\t\t\t\tvar a = el[i];\n\t\t\t\t\t\t\tposition(a.offset);\n\t\t\t\t\t\t\ta.locator = copyLocator(locator, {});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdomBuilder.locator = locator2;\n\t\t\t\t\t\tif (appendElement(el, domBuilder, currentNSMap)) {\n\t\t\t\t\t\t\tparseStack.push(el);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdomBuilder.locator = locator;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (appendElement(el, domBuilder, currentNSMap)) {\n\t\t\t\t\t\t\tparseStack.push(el);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isHTML && !el.closed) {\n\t\t\t\t\t\tend = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tend++;\n\t\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (e instanceof ParseError) {\n\t\t\t\tthrow e;\n\t\t\t} else if (e instanceof DOMException) {\n\t\t\t\tthrow new ParseError(e.name + ': ' + e.message, domBuilder.locator, e);\n\t\t\t}\n\t\t\terrorHandler.error('element parse error: ' + e);\n\t\t\tend = -1;\n\t\t}\n\t\tif (end > start) {\n\t\t\tstart = end;\n\t\t} else {\n\t\t\t//Possible sax fallback here, risk of positional error\n\t\t\tappendText(Math.max(tagStart, start) + 1);\n\t\t}\n\t}\n}\n\nfunction copyLocator(f, t) {\n\tt.lineNumber = f.lineNumber;\n\tt.columnNumber = f.columnNumber;\n\treturn t;\n}\n\n/**\n * @returns\n * end of the elementStartPart(end of elementEndPart for selfClosed el)\n * @see {@link #appendElement}\n */\nfunction parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler, isHTML) {\n\t/**\n\t * @param {string} qname\n\t * @param {string} value\n\t * @param {number} startIndex\n\t */\n\tfunction addAttribute(qname, value, startIndex) {\n\t\tif (hasOwn(el.attributeNames, qname)) {\n\t\t\treturn errorHandler.fatalError('Attribute ' + qname + ' redefined');\n\t\t}\n\t\tif (!isHTML && value.indexOf('<') >= 0) {\n\t\t\treturn errorHandler.fatalError(\"Unescaped '<' not allowed in attributes values\");\n\t\t}\n\t\tel.addValue(\n\t\t\tqname,\n\t\t\t// @see https://www.w3.org/TR/xml/#AVNormalize\n\t\t\t// since the xmldom sax parser does not \"interpret\" DTD the following is not implemented:\n\t\t\t// - recursive replacement of (DTD) entity references\n\t\t\t// - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA\n\t\t\tvalue.replace(/[\\t\\n\\r]/g, ' ').replace(ENTITY_REG, entityReplacer),\n\t\t\tstartIndex\n\t\t);\n\t}\n\n\tvar attrName;\n\tvar value;\n\tvar p = ++start;\n\tvar s = S_TAG; //status\n\twhile (true) {\n\t\tvar c = source.charAt(p);\n\t\tswitch (c) {\n\t\t\tcase '=':\n\t\t\t\tif (s === S_ATTR) {\n\t\t\t\t\t//attrName\n\t\t\t\t\tattrName = source.slice(start, p);\n\t\t\t\t\ts = S_EQ;\n\t\t\t\t} else if (s === S_ATTR_SPACE) {\n\t\t\t\t\ts = S_EQ;\n\t\t\t\t} else {\n\t\t\t\t\t//fatalError: equal must after attrName or space after attrName\n\t\t\t\t\tthrow new Error('attribute equal must after attrName'); // No known test case\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"'\":\n\t\t\tcase '\"':\n\t\t\t\tif (\n\t\t\t\t\ts === S_EQ ||\n\t\t\t\t\ts === S_ATTR //|| s == S_ATTR_SPACE\n\t\t\t\t) {\n\t\t\t\t\t//equal\n\t\t\t\t\tif (s === S_ATTR) {\n\t\t\t\t\t\terrorHandler.warning('attribute value must after \"=\"');\n\t\t\t\t\t\tattrName = source.slice(start, p);\n\t\t\t\t\t}\n\t\t\t\t\tstart = p + 1;\n\t\t\t\t\tp = source.indexOf(c, start);\n\t\t\t\t\tif (p > 0) {\n\t\t\t\t\t\tvalue = source.slice(start, p);\n\t\t\t\t\t\taddAttribute(attrName, value, start - 1);\n\t\t\t\t\t\ts = S_ATTR_END;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//fatalError: no end quot match\n\t\t\t\t\t\tthrow new Error(\"attribute value no end '\" + c + \"' match\");\n\t\t\t\t\t}\n\t\t\t\t} else if (s == S_ATTR_NOQUOT_VALUE) {\n\t\t\t\t\tvalue = source.slice(start, p);\n\t\t\t\t\taddAttribute(attrName, value, start);\n\t\t\t\t\terrorHandler.warning('attribute \"' + attrName + '\" missed start quot(' + c + ')!!');\n\t\t\t\t\tstart = p + 1;\n\t\t\t\t\ts = S_ATTR_END;\n\t\t\t\t} else {\n\t\t\t\t\t//fatalError: no equal before\n\t\t\t\t\tthrow new Error('attribute value must after \"=\"'); // No known test case\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\tswitch (s) {\n\t\t\t\t\tcase S_TAG:\n\t\t\t\t\t\tel.setTagName(source.slice(start, p));\n\t\t\t\t\tcase S_ATTR_END:\n\t\t\t\t\tcase S_TAG_SPACE:\n\t\t\t\t\tcase S_TAG_CLOSE:\n\t\t\t\t\t\ts = S_TAG_CLOSE;\n\t\t\t\t\t\tel.closed = true;\n\t\t\t\t\tcase S_ATTR_NOQUOT_VALUE:\n\t\t\t\t\tcase S_ATTR:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_ATTR_SPACE:\n\t\t\t\t\t\tel.closed = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//case S_EQ:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(\"attribute invalid close char('/')\"); // No known test case\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '': //end document\n\t\t\t\terrorHandler.error('unexpected end of input');\n\t\t\t\tif (s == S_TAG) {\n\t\t\t\t\tel.setTagName(source.slice(start, p));\n\t\t\t\t}\n\t\t\t\treturn p;\n\t\t\tcase '>':\n\t\t\t\tswitch (s) {\n\t\t\t\t\tcase S_TAG:\n\t\t\t\t\t\tel.setTagName(source.slice(start, p));\n\t\t\t\t\tcase S_ATTR_END:\n\t\t\t\t\tcase S_TAG_SPACE:\n\t\t\t\t\tcase S_TAG_CLOSE:\n\t\t\t\t\t\tbreak; //normal\n\t\t\t\t\tcase S_ATTR_NOQUOT_VALUE: //Compatible state\n\t\t\t\t\tcase S_ATTR:\n\t\t\t\t\t\tvalue = source.slice(start, p);\n\t\t\t\t\t\tif (value.slice(-1) === '/') {\n\t\t\t\t\t\t\tel.closed = true;\n\t\t\t\t\t\t\tvalue = value.slice(0, -1);\n\t\t\t\t\t\t}\n\t\t\t\t\tcase S_ATTR_SPACE:\n\t\t\t\t\t\tif (s === S_ATTR_SPACE) {\n\t\t\t\t\t\t\tvalue = attrName;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (s == S_ATTR_NOQUOT_VALUE) {\n\t\t\t\t\t\t\terrorHandler.warning('attribute \"' + value + '\" missed quot(\")!');\n\t\t\t\t\t\t\taddAttribute(attrName, value, start);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (!isHTML) {\n\t\t\t\t\t\t\t\terrorHandler.warning('attribute \"' + value + '\" missed value!! \"' + value + '\" instead!!');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\taddAttribute(value, value, start);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_EQ:\n\t\t\t\t\t\tif (!isHTML) {\n\t\t\t\t\t\t\treturn errorHandler.fatalError('AttValue: \\' or \" expected');\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn p;\n\t\t\t/*xml space '\\x20' | #x9 | #xD | #xA; */\n\t\t\tcase '\\u0080':\n\t\t\t\tc = ' ';\n\t\t\tdefault:\n\t\t\t\tif (c <= ' ') {\n\t\t\t\t\t//space\n\t\t\t\t\tswitch (s) {\n\t\t\t\t\t\tcase S_TAG:\n\t\t\t\t\t\t\tel.setTagName(source.slice(start, p)); //tagName\n\t\t\t\t\t\t\ts = S_TAG_SPACE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase S_ATTR:\n\t\t\t\t\t\t\tattrName = source.slice(start, p);\n\t\t\t\t\t\t\ts = S_ATTR_SPACE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase S_ATTR_NOQUOT_VALUE:\n\t\t\t\t\t\t\tvar value = source.slice(start, p);\n\t\t\t\t\t\t\terrorHandler.warning('attribute \"' + value + '\" missed quot(\")!!');\n\t\t\t\t\t\t\taddAttribute(attrName, value, start);\n\t\t\t\t\t\tcase S_ATTR_END:\n\t\t\t\t\t\t\ts = S_TAG_SPACE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t//case S_TAG_SPACE:\n\t\t\t\t\t\t//case S_EQ:\n\t\t\t\t\t\t//case S_ATTR_SPACE:\n\t\t\t\t\t\t//\tvoid();break;\n\t\t\t\t\t\t//case S_TAG_CLOSE:\n\t\t\t\t\t\t//ignore warning\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t//not space\n\t\t\t\t\t//S_TAG,\tS_ATTR,\tS_EQ,\tS_ATTR_NOQUOT_VALUE\n\t\t\t\t\t//S_ATTR_SPACE,\tS_ATTR_END,\tS_TAG_SPACE, S_TAG_CLOSE\n\t\t\t\t\tswitch (s) {\n\t\t\t\t\t\t//case S_TAG:void();break;\n\t\t\t\t\t\t//case S_ATTR:void();break;\n\t\t\t\t\t\t//case S_ATTR_NOQUOT_VALUE:void();break;\n\t\t\t\t\t\tcase S_ATTR_SPACE:\n\t\t\t\t\t\t\tif (!isHTML) {\n\t\t\t\t\t\t\t\terrorHandler.warning('attribute \"' + attrName + '\" missed value!! \"' + attrName + '\" instead2!!');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\taddAttribute(attrName, attrName, start);\n\t\t\t\t\t\t\tstart = p;\n\t\t\t\t\t\t\ts = S_ATTR;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase S_ATTR_END:\n\t\t\t\t\t\t\terrorHandler.warning('attribute space is required\"' + attrName + '\"!!');\n\t\t\t\t\t\tcase S_TAG_SPACE:\n\t\t\t\t\t\t\ts = S_ATTR;\n\t\t\t\t\t\t\tstart = p;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase S_EQ:\n\t\t\t\t\t\t\ts = S_ATTR_NOQUOT_VALUE;\n\t\t\t\t\t\t\tstart = p;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase S_TAG_CLOSE:\n\t\t\t\t\t\t\tthrow new Error(\"elements closed character '/' and '>' must be connected to\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t} //end outer switch\n\t\tp++;\n\t}\n}\n\n/**\n * @returns\n * `true` if a new namespace has been defined.\n */\nfunction appendElement(el, domBuilder, currentNSMap) {\n\tvar tagName = el.tagName;\n\tvar localNSMap = null;\n\tvar i = el.length;\n\twhile (i--) {\n\t\tvar a = el[i];\n\t\tvar qName = a.qName;\n\t\tvar value = a.value;\n\t\tvar nsp = qName.indexOf(':');\n\t\tif (nsp > 0) {\n\t\t\tvar prefix = (a.prefix = qName.slice(0, nsp));\n\t\t\tvar localName = qName.slice(nsp + 1);\n\t\t\tvar nsPrefix = prefix === 'xmlns' && localName;\n\t\t} else {\n\t\t\tlocalName = qName;\n\t\t\tprefix = null;\n\t\t\tnsPrefix = qName === 'xmlns' && '';\n\t\t}\n\t\t//can not set prefix,because prefix !== ''\n\t\ta.localName = localName;\n\t\t//prefix == null for no ns prefix attribute\n\t\tif (nsPrefix !== false) {\n\t\t\t//hack!!\n\t\t\tif (localNSMap == null) {\n\t\t\t\tlocalNSMap = Object.create(null);\n\t\t\t\t_copy(currentNSMap, (currentNSMap = Object.create(null)));\n\t\t\t}\n\t\t\tcurrentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;\n\t\t\ta.uri = NAMESPACE.XMLNS;\n\t\t\tdomBuilder.startPrefixMapping(nsPrefix, value);\n\t\t}\n\t}\n\tvar i = el.length;\n\twhile (i--) {\n\t\ta = el[i];\n\t\tif (a.prefix) {\n\t\t\t//no prefix attribute has no namespace\n\t\t\tif (a.prefix === 'xml') {\n\t\t\t\ta.uri = NAMESPACE.XML;\n\t\t\t}\n\t\t\tif (a.prefix !== 'xmlns') {\n\t\t\t\ta.uri = currentNSMap[a.prefix];\n\t\t\t}\n\t\t}\n\t}\n\tvar nsp = tagName.indexOf(':');\n\tif (nsp > 0) {\n\t\tprefix = el.prefix = tagName.slice(0, nsp);\n\t\tlocalName = el.localName = tagName.slice(nsp + 1);\n\t} else {\n\t\tprefix = null; //important!!\n\t\tlocalName = el.localName = tagName;\n\t}\n\t//no prefix element has default namespace\n\tvar ns = (el.uri = currentNSMap[prefix || '']);\n\tdomBuilder.startElement(ns, localName, tagName, el);\n\t//endPrefixMapping and startPrefixMapping have not any help for dom builder\n\t//localNSMap = null\n\tif (el.closed) {\n\t\tdomBuilder.endElement(ns, localName, tagName);\n\t\tif (localNSMap) {\n\t\t\tfor (prefix in localNSMap) {\n\t\t\t\tif (hasOwn(localNSMap, prefix)) {\n\t\t\t\t\tdomBuilder.endPrefixMapping(prefix);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tel.currentNSMap = currentNSMap;\n\t\tel.localNSMap = localNSMap;\n\t\t//parseStack.push(el);\n\t\treturn true;\n\t}\n}\n\nfunction parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {\n\t// https://html.spec.whatwg.org/#raw-text-elements\n\t// https://html.spec.whatwg.org/#escapable-raw-text-elements\n\t// https://html.spec.whatwg.org/#cdata-rcdata-restrictions:raw-text-elements\n\t// TODO: https://html.spec.whatwg.org/#cdata-rcdata-restrictions\n\tvar isEscapableRaw = isHTMLEscapableRawTextElement(tagName);\n\tif (isEscapableRaw || isHTMLRawTextElement(tagName)) {\n\t\tvar elEndStart = source.indexOf('</' + tagName + '>', elStartEnd);\n\t\tvar text = source.substring(elStartEnd + 1, elEndStart);\n\n\t\tif (isEscapableRaw) {\n\t\t\ttext = text.replace(ENTITY_REG, entityReplacer);\n\t\t}\n\t\tdomBuilder.characters(text, 0, text.length);\n\t\treturn elEndStart;\n\t}\n\treturn elStartEnd + 1;\n}\n\nfunction _copy(source, target) {\n\tfor (var n in source) {\n\t\tif (hasOwn(source, n)) {\n\t\t\ttarget[n] = source[n];\n\t\t}\n\t}\n}\n\n/**\n * @typedef ParseUtils\n * @property {function(relativeIndex: number?): string | undefined} char\n * Provides look ahead access to a singe character relative to the current index.\n * @property {function(): number} getIndex\n * Provides read-only access to the current index.\n * @property {function(reg: RegExp): string | null} getMatch\n * Applies the provided regular expression enforcing that it starts at the current index and\n * returns the complete matching string,\n * and moves the current index by the length of the matching string.\n * @property {function(): string} getSource\n * Provides read-only access to the complete source.\n * @property {function(places: number?): void} skip\n * moves the current index by places (defaults to 1)\n * @property {function(): number} skipBlanks\n * Moves the current index by the amount of white space that directly follows the current index\n * and returns the amount of whitespace chars skipped (0..n),\n * or -1 if the end of the source was reached.\n * @property {function(): string} substringFromIndex\n * creates a substring from the current index to the end of `source`\n * @property {function(compareWith: string): boolean} substringStartsWith\n * Checks if `source` contains `compareWith`, starting from the current index.\n * @property {function(compareWith: string): boolean} substringStartsWithCaseInsensitive\n * Checks if `source` contains `compareWith`, starting from the current index,\n * comparing the upper case of both sides.\n * @see {@link parseUtils}\n */\n\n/**\n * A temporary scope for parsing and look ahead operations in `source`,\n * starting from index `start`.\n *\n * Some operations move the current index by a number of positions,\n * after which `getIndex` returns the new index.\n *\n * @param {string} source\n * @param {number} start\n * @returns {ParseUtils}\n */\nfunction parseUtils(source, start) {\n\tvar index = start;\n\n\tfunction char(n) {\n\t\tn = n || 0;\n\t\treturn source.charAt(index + n);\n\t}\n\n\tfunction skip(n) {\n\t\tn = n || 1;\n\t\tindex += n;\n\t}\n\n\tfunction skipBlanks() {\n\t\tvar blanks = 0;\n\t\twhile (index < source.length) {\n\t\t\tvar c = char();\n\t\t\tif (c !== ' ' && c !== '\\n' && c !== '\\t' && c !== '\\r') {\n\t\t\t\treturn blanks;\n\t\t\t}\n\t\t\tblanks++;\n\t\t\tskip();\n\t\t}\n\t\treturn -1;\n\t}\n\tfunction substringFromIndex() {\n\t\treturn source.substring(index);\n\t}\n\tfunction substringStartsWith(text) {\n\t\treturn source.substring(index, index + text.length) === text;\n\t}\n\tfunction substringStartsWithCaseInsensitive(text) {\n\t\treturn source.substring(index, index + text.length).toUpperCase() === text.toUpperCase();\n\t}\n\n\tfunction getMatch(args) {\n\t\tvar expr = g.reg('^', args);\n\t\tvar match = expr.exec(substringFromIndex());\n\t\tif (match) {\n\t\t\tskip(match[0].length);\n\t\t\treturn match[0];\n\t\t}\n\t\treturn null;\n\t}\n\treturn {\n\t\tchar: char,\n\t\tgetIndex: function () {\n\t\t\treturn index;\n\t\t},\n\t\tgetMatch: getMatch,\n\t\tgetSource: function () {\n\t\t\treturn source;\n\t\t},\n\t\tskip: skip,\n\t\tskipBlanks: skipBlanks,\n\t\tsubstringFromIndex: substringFromIndex,\n\t\tsubstringStartsWith: substringStartsWith,\n\t\tsubstringStartsWithCaseInsensitive: substringStartsWithCaseInsensitive,\n\t};\n}\n\n/**\n * @param {ParseUtils} p\n * @param {DOMHandler} errorHandler\n * @returns {string}\n */\nfunction parseDoctypeInternalSubset(p, errorHandler) {\n\t/**\n\t * @param {ParseUtils} p\n\t * @param {DOMHandler} errorHandler\n\t * @returns {string}\n\t */\n\tfunction parsePI(p, errorHandler) {\n\t\tvar match = g.PI.exec(p.substringFromIndex());\n\t\tif (!match) {\n\t\t\treturn errorHandler.fatalError('processing instruction is not well-formed at position ' + p.getIndex());\n\t\t}\n\t\tif (match[1].toLowerCase() === 'xml') {\n\t\t\treturn errorHandler.fatalError(\n\t\t\t\t'xml declaration is only allowed at the start of the document, but found at position ' + p.getIndex()\n\t\t\t);\n\t\t}\n\t\tp.skip(match[0].length);\n\t\treturn match[0];\n\t}\n\t// Parse internal subset\n\tvar source = p.getSource();\n\tif (p.char() === '[') {\n\t\tp.skip(1);\n\t\tvar intSubsetStart = p.getIndex();\n\t\twhile (p.getIndex() < source.length) {\n\t\t\tp.skipBlanks();\n\t\t\tif (p.char() === ']') {\n\t\t\t\tvar internalSubset = source.substring(intSubsetStart, p.getIndex());\n\t\t\t\tp.skip(1);\n\t\t\t\treturn internalSubset;\n\t\t\t}\n\t\t\tvar current = null;\n\t\t\t// Only in external subset\n\t\t\t// if (char() === '<' && char(1) === '!' && char(2) === '[') {\n\t\t\t// \tparseConditionalSections(p, errorHandler);\n\t\t\t// } else\n\t\t\tif (p.char() === '<' && p.char(1) === '!') {\n\t\t\t\tswitch (p.char(2)) {\n\t\t\t\t\tcase 'E': // ELEMENT | ENTITY\n\t\t\t\t\t\tif (p.char(3) === 'L') {\n\t\t\t\t\t\t\tcurrent = p.getMatch(g.elementdecl);\n\t\t\t\t\t\t} else if (p.char(3) === 'N') {\n\t\t\t\t\t\t\tcurrent = p.getMatch(g.EntityDecl);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'A': // ATTRIBUTE\n\t\t\t\t\t\tcurrent = p.getMatch(g.AttlistDecl);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'N': // NOTATION\n\t\t\t\t\t\tcurrent = p.getMatch(g.NotationDecl);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '-': // COMMENT\n\t\t\t\t\t\tcurrent = p.getMatch(g.Comment);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (p.char() === '<' && p.char(1) === '?') {\n\t\t\t\tcurrent = parsePI(p, errorHandler);\n\t\t\t} else if (p.char() === '%') {\n\t\t\t\tcurrent = p.getMatch(g.PEReference);\n\t\t\t} else {\n\t\t\t\treturn errorHandler.fatalError('Error detected in Markup declaration');\n\t\t\t}\n\t\t\tif (!current) {\n\t\t\t\treturn errorHandler.fatalError('Error in internal subset at position ' + p.getIndex());\n\t\t\t}\n\t\t}\n\t\treturn errorHandler.fatalError('doctype internal subset is not well-formed, missing ]');\n\t}\n}\n\n/**\n * Called when the parser encounters an element starting with '<!'.\n *\n * @param {string} source\n * The xml.\n * @param {number} start\n * the start index of the '<!'\n * @param {DOMHandler} domBuilder\n * @param {DOMHandler} errorHandler\n * @param {boolean} isHTML\n * @returns {number | never}\n * The end index of the element.\n * @throws {ParseError}\n * In case the element is not well-formed.\n */\nfunction parseDoctypeCommentOrCData(source, start, domBuilder, errorHandler, isHTML) {\n\tvar p = parseUtils(source, start);\n\n\tswitch (isHTML ? p.char(2).toUpperCase() : p.char(2)) {\n\t\tcase '-':\n\t\t\t// should be a comment\n\t\t\tvar comment = p.getMatch(g.Comment);\n\t\t\tif (comment) {\n\t\t\t\tdomBuilder.comment(comment, g.COMMENT_START.length, comment.length - g.COMMENT_START.length - g.COMMENT_END.length);\n\t\t\t\treturn p.getIndex();\n\t\t\t} else {\n\t\t\t\treturn errorHandler.fatalError('comment is not well-formed at position ' + p.getIndex());\n\t\t\t}\n\t\tcase '[':\n\t\t\t// should be CDATA\n\t\t\tvar cdata = p.getMatch(g.CDSect);\n\t\t\tif (cdata) {\n\t\t\t\tif (!isHTML && !domBuilder.currentElement) {\n\t\t\t\t\treturn errorHandler.fatalError('CDATA outside of element');\n\t\t\t\t}\n\t\t\t\tdomBuilder.startCDATA();\n\t\t\t\tdomBuilder.characters(cdata, g.CDATA_START.length, cdata.length - g.CDATA_START.length - g.CDATA_END.length);\n\t\t\t\tdomBuilder.endCDATA();\n\t\t\t\treturn p.getIndex();\n\t\t\t} else {\n\t\t\t\treturn errorHandler.fatalError('Invalid CDATA starting at position ' + start);\n\t\t\t}\n\t\tcase 'D': {\n\t\t\t// should be DOCTYPE\n\t\t\tif (domBuilder.doc && domBuilder.doc.documentElement) {\n\t\t\t\treturn errorHandler.fatalError('Doctype not allowed inside or after documentElement at position ' + p.getIndex());\n\t\t\t}\n\t\t\tif (isHTML ? !p.substringStartsWithCaseInsensitive(g.DOCTYPE_DECL_START) : !p.substringStartsWith(g.DOCTYPE_DECL_START)) {\n\t\t\t\treturn errorHandler.fatalError('Expected ' + g.DOCTYPE_DECL_START + ' at position ' + p.getIndex());\n\t\t\t}\n\t\t\tp.skip(g.DOCTYPE_DECL_START.length);\n\t\t\tif (p.skipBlanks() < 1) {\n\t\t\t\treturn errorHandler.fatalError('Expected whitespace after ' + g.DOCTYPE_DECL_START + ' at position ' + p.getIndex());\n\t\t\t}\n\n\t\t\tvar doctype = {\n\t\t\t\tname: undefined,\n\t\t\t\tpublicId: undefined,\n\t\t\t\tsystemId: undefined,\n\t\t\t\tinternalSubset: undefined,\n\t\t\t};\n\t\t\t// Parse the DOCTYPE name\n\t\t\tdoctype.name = p.getMatch(g.Name);\n\t\t\tif (!doctype.name)\n\t\t\t\treturn errorHandler.fatalError('doctype name missing or contains unexpected characters at position ' + p.getIndex());\n\n\t\t\tif (isHTML && doctype.name.toLowerCase() !== 'html') {\n\t\t\t\terrorHandler.warning('Unexpected DOCTYPE in HTML document at position ' + p.getIndex());\n\t\t\t}\n\t\t\tp.skipBlanks();\n\n\t\t\t// Check for ExternalID\n\t\t\tif (p.substringStartsWith(g.PUBLIC) || p.substringStartsWith(g.SYSTEM)) {\n\t\t\t\tvar match = g.ExternalID_match.exec(p.substringFromIndex());\n\t\t\t\tif (!match) {\n\t\t\t\t\treturn errorHandler.fatalError('doctype external id is not well-formed at position ' + p.getIndex());\n\t\t\t\t}\n\t\t\t\tif (match.groups.SystemLiteralOnly !== undefined) {\n\t\t\t\t\tdoctype.systemId = match.groups.SystemLiteralOnly;\n\t\t\t\t} else {\n\t\t\t\t\tdoctype.systemId = match.groups.SystemLiteral;\n\t\t\t\t\tdoctype.publicId = match.groups.PubidLiteral;\n\t\t\t\t}\n\t\t\t\tp.skip(match[0].length);\n\t\t\t} else if (isHTML && p.substringStartsWithCaseInsensitive(g.SYSTEM)) {\n\t\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#doctype-legacy-string\n\t\t\t\tp.skip(g.SYSTEM.length);\n\t\t\t\tif (p.skipBlanks() < 1) {\n\t\t\t\t\treturn errorHandler.fatalError('Expected whitespace after ' + g.SYSTEM + ' at position ' + p.getIndex());\n\t\t\t\t}\n\t\t\t\tdoctype.systemId = p.getMatch(g.ABOUT_LEGACY_COMPAT_SystemLiteral);\n\t\t\t\tif (!doctype.systemId) {\n\t\t\t\t\treturn errorHandler.fatalError(\n\t\t\t\t\t\t'Expected ' + g.ABOUT_LEGACY_COMPAT + ' in single or double quotes after ' + g.SYSTEM + ' at position ' + p.getIndex()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isHTML && doctype.systemId && !g.ABOUT_LEGACY_COMPAT_SystemLiteral.test(doctype.systemId)) {\n\t\t\t\terrorHandler.warning('Unexpected doctype.systemId in HTML document at position ' + p.getIndex());\n\t\t\t}\n\t\t\tif (!isHTML) {\n\t\t\t\tp.skipBlanks();\n\t\t\t\tdoctype.internalSubset = parseDoctypeInternalSubset(p, errorHandler);\n\t\t\t}\n\t\t\tp.skipBlanks();\n\t\t\tif (p.char() !== '>') {\n\t\t\t\treturn errorHandler.fatalError('doctype not terminated with > at position ' + p.getIndex());\n\t\t\t}\n\t\t\tp.skip(1);\n\t\t\tdomBuilder.startDTD(doctype.name, doctype.publicId, doctype.systemId, doctype.internalSubset);\n\t\t\tdomBuilder.endDTD();\n\t\t\treturn p.getIndex();\n\t\t}\n\t\tdefault:\n\t\t\treturn errorHandler.fatalError('Not well-formed XML starting with \"<!\" at position ' + start);\n\t}\n}\n\nfunction parseProcessingInstruction(source, start, domBuilder, errorHandler) {\n\tvar match = source.substring(start).match(g.PI);\n\tif (!match) {\n\t\treturn errorHandler.fatalError('Invalid processing instruction starting at position ' + start);\n\t}\n\tif (match[1].toLowerCase() === 'xml') {\n\t\tif (start > 0) {\n\t\t\treturn errorHandler.fatalError(\n\t\t\t\t'processing instruction at position ' + start + ' is an xml declaration which is only at the start of the document'\n\t\t\t);\n\t\t}\n\t\tif (!g.XMLDecl.test(source.substring(start))) {\n\t\t\treturn errorHandler.fatalError('xml declaration is not well-formed');\n\t\t}\n\t}\n\tdomBuilder.processingInstruction(match[1], match[2]);\n\treturn start + match[0].length;\n}\n\nfunction ElementAttributes() {\n\tthis.attributeNames = Object.create(null);\n}\n\nElementAttributes.prototype = {\n\tsetTagName: function (tagName) {\n\t\tif (!g.QName_exact.test(tagName)) {\n\t\t\tthrow new Error('invalid tagName:' + tagName);\n\t\t}\n\t\tthis.tagName = tagName;\n\t},\n\taddValue: function (qName, value, offset) {\n\t\tif (!g.QName_exact.test(qName)) {\n\t\t\tthrow new Error('invalid attribute:' + qName);\n\t\t}\n\t\tthis.attributeNames[qName] = this.length;\n\t\tthis[this.length++] = { qName: qName, value: value, offset: offset };\n\t},\n\tlength: 0,\n\tgetLocalName: function (i) {\n\t\treturn this[i].localName;\n\t},\n\tgetLocator: function (i) {\n\t\treturn this[i].locator;\n\t},\n\tgetQName: function (i) {\n\t\treturn this[i].qName;\n\t},\n\tgetURI: function (i) {\n\t\treturn this[i].uri;\n\t},\n\tgetValue: function (i) {\n\t\treturn this[i].value;\n\t},\n\t//\t,getIndex:function(uri, localName)){\n\t//\t\tif(localName){\n\t//\n\t//\t\t}else{\n\t//\t\t\tvar qName = uri\n\t//\t\t}\n\t//\t},\n\t//\tgetValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},\n\t//\tgetType:function(uri,localName){}\n\t//\tgetType:function(i){},\n};\n\nexports.XMLReader = XMLReader;\nexports.parseUtils = parseUtils;\nexports.parseDoctypeCommentOrCData = parseDoctypeCommentOrCData;\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,WAAW,GAAGC,OAAO,CAAC,eAAe,CAAC;AAC1C,IAAIC,CAAC,GAAGD,OAAO,CAAC,WAAW,CAAC;AAC5B,IAAIE,MAAM,GAAGF,OAAO,CAAC,UAAU,CAAC;AAEhC,IAAIG,6BAA6B,GAAGJ,WAAW,CAACI,6BAA6B;AAC7E,IAAIC,cAAc,GAAGL,WAAW,CAACK,cAAc;AAC/C,IAAIC,oBAAoB,GAAGN,WAAW,CAACM,oBAAoB;AAC3D,IAAIC,MAAM,GAAGP,WAAW,CAACO,MAAM;AAC/B,IAAIC,SAAS,GAAGR,WAAW,CAACQ,SAAS;AACrC,IAAIC,UAAU,GAAGN,MAAM,CAACM,UAAU;AAClC,IAAIC,YAAY,GAAGP,MAAM,CAACO,YAAY;;AAEtC;;AAEA;AACA;AACA,IAAIC,KAAK,GAAG,CAAC,CAAC,CAAC;AACf,IAAIC,MAAM,GAAG,CAAC,CAAC,CAAC;AAChB,IAAIC,YAAY,GAAG,CAAC,CAAC,CAAC;AACtB,IAAIC,IAAI,GAAG,CAAC,CAAC,CAAC;AACd,IAAIC,mBAAmB,GAAG,CAAC,CAAC,CAAC;AAC7B,IAAIC,UAAU,GAAG,CAAC,CAAC,CAAC;AACpB,IAAIC,WAAW,GAAG,CAAC,CAAC,CAAC;AACrB,IAAIC,WAAW,GAAG,CAAC,CAAC,CAAC;;AAErB,SAASC,SAASA,CAAA,EAAG,CAAC;AAEtBA,SAAS,CAACC,SAAS,GAAG;EACrBC,KAAK,EAAE,SAAAA,CAAUC,MAAM,EAAEC,YAAY,EAAEC,SAAS,EAAE;IACjD,IAAIC,UAAU,GAAG,IAAI,CAACA,UAAU;IAChCA,UAAU,CAACC,aAAa,CAAC,CAAC;IAC1BC,KAAK,CAACJ,YAAY,EAAGA,YAAY,GAAGK,MAAM,CAACC,MAAM,CAAC,IAAI,CAAE,CAAC;IACzDR,KAAK,CAACC,MAAM,EAAEC,YAAY,EAAEC,SAAS,EAAEC,UAAU,EAAE,IAAI,CAACK,YAAY,CAAC;IACrEL,UAAU,CAACM,WAAW,CAAC,CAAC;EACzB;AACD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,UAAU,GAAG,WAAW;AAE5B,SAASX,KAAKA,CAACC,MAAM,EAAEW,gBAAgB,EAAET,SAAS,EAAEC,UAAU,EAAEK,YAAY,EAAE;EAC7E,IAAII,MAAM,GAAG7B,cAAc,CAACoB,UAAU,CAACU,QAAQ,CAAC;EAChD,IAAIb,MAAM,CAACc,OAAO,CAAClC,CAAC,CAACmC,6BAA6B,CAAC,IAAI,CAAC,EAAE;IACzDP,YAAY,CAACQ,OAAO,CAAC,iEAAiE,CAAC;EACxF;EAEA,SAASC,iBAAiBA,CAACC,IAAI,EAAE;IAChC;IACA;IACA,IAAIA,IAAI,GAAG,MAAM,EAAE;MAClBA,IAAI,IAAI,OAAO;MACf,IAAIC,UAAU,GAAG,MAAM,IAAID,IAAI,IAAI,EAAE,CAAC;QACrCE,UAAU,GAAG,MAAM,IAAIF,IAAI,GAAG,KAAK,CAAC;MAErC,OAAOG,MAAM,CAACC,YAAY,CAACH,UAAU,EAAEC,UAAU,CAAC;IACnD,CAAC,MAAM;MACN,OAAOC,MAAM,CAACC,YAAY,CAACJ,IAAI,CAAC;IACjC;EACD;EAEA,SAASK,cAAcA,CAACC,CAAC,EAAE;IAC1B,IAAIC,QAAQ,GAAGD,CAAC,CAACA,CAAC,CAACE,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,GAAGF,CAAC,GAAGA,CAAC,GAAG,GAAG;IACpD,IAAI,CAACZ,MAAM,IAAIa,QAAQ,KAAKD,CAAC,EAAE;MAC9BhB,YAAY,CAACmB,KAAK,CAAC,wBAAwB,CAAC;MAC5C,OAAOH,CAAC;IACT;IACA,IAAII,KAAK,GAAGhD,CAAC,CAACiD,SAAS,CAACC,IAAI,CAACL,QAAQ,CAAC;IACtC,IAAI,CAACG,KAAK,IAAIA,KAAK,CAAC,CAAC,CAAC,CAACF,MAAM,KAAKD,QAAQ,CAACC,MAAM,EAAE;MAClDlB,YAAY,CAACmB,KAAK,CAAC,4CAA4C,GAAGH,CAAC,CAAC;MACpE,OAAOA,CAAC;IACT;IACA,IAAIO,CAAC,GAAGN,QAAQ,CAACO,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAC7B,IAAI/C,MAAM,CAACiB,SAAS,EAAE6B,CAAC,CAAC,EAAE;MACzB,OAAO7B,SAAS,CAAC6B,CAAC,CAAC;IACpB,CAAC,MAAM,IAAIA,CAAC,CAACE,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;MAC/B,OAAOhB,iBAAiB,CAACiB,QAAQ,CAACH,CAAC,CAACI,SAAS,CAAC,CAAC,CAAC,CAACC,OAAO,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,CAAC;IACtE,CAAC,MAAM;MACN5B,YAAY,CAACmB,KAAK,CAAC,mBAAmB,GAAGH,CAAC,CAAC;MAC3C,OAAOA,CAAC;IACT;EACD;EAEA,SAASa,UAAUA,CAACC,GAAG,EAAE;IACxB;IACA,IAAIA,GAAG,GAAGC,KAAK,EAAE;MAChB,IAAIC,EAAE,GAAGxC,MAAM,CAACmC,SAAS,CAACI,KAAK,EAAED,GAAG,CAAC,CAACF,OAAO,CAAC1B,UAAU,EAAEa,cAAc,CAAC;MACzEkB,OAAO,IAAIC,QAAQ,CAACH,KAAK,CAAC;MAC1BpC,UAAU,CAACwC,UAAU,CAACH,EAAE,EAAE,CAAC,EAAEF,GAAG,GAAGC,KAAK,CAAC;MACzCA,KAAK,GAAGD,GAAG;IACZ;EACD;EAEA,IAAIM,SAAS,GAAG,CAAC;EACjB,IAAIC,OAAO,GAAG,CAAC;EACf,IAAIC,WAAW,GAAG,aAAa;EAC/B,IAAIL,OAAO,GAAGtC,UAAU,CAACsC,OAAO;EAEhC,SAASC,QAAQA,CAACK,CAAC,EAAEC,CAAC,EAAE;IACvB,OAAOD,CAAC,IAAIF,OAAO,KAAKG,CAAC,GAAGF,WAAW,CAAChB,IAAI,CAAC9B,MAAM,CAAC,CAAC,EAAE;MACtD4C,SAAS,GAAGC,OAAO;MACnBA,OAAO,GAAGG,CAAC,CAACC,KAAK,GAAGD,CAAC,CAAC,CAAC,CAAC,CAACtB,MAAM;MAC/Be,OAAO,CAACS,UAAU,EAAE;IACrB;IACAT,OAAO,CAACU,YAAY,GAAGJ,CAAC,GAAGH,SAAS,GAAG,CAAC;EACzC;EAEA,IAAIQ,UAAU,GAAG,CAAC;IAAEC,YAAY,EAAE1C;EAAiB,CAAC,CAAC;EACrD,IAAI2C,YAAY,GAAG,EAAE;EACrB,IAAIf,KAAK,GAAG,CAAC;EACb,OAAO,IAAI,EAAE;IACZ,IAAI;MACH,IAAIgB,QAAQ,GAAGvD,MAAM,CAACc,OAAO,CAAC,GAAG,EAAEyB,KAAK,CAAC;MACzC,IAAIgB,QAAQ,GAAG,CAAC,EAAE;QACjB,IAAI,CAAC3C,MAAM,IAAI0C,YAAY,CAAC5B,MAAM,GAAG,CAAC,EAAE;UACvC,OAAOlB,YAAY,CAACgD,UAAU,CAAC,uBAAuB,GAAGF,YAAY,CAACG,IAAI,CAAC,IAAI,CAAC,CAAC;QAClF;QACA,IAAI,CAACzD,MAAM,CAACmC,SAAS,CAACI,KAAK,CAAC,CAACX,KAAK,CAAC,OAAO,CAAC,EAAE;UAC5C,IAAI8B,GAAG,GAAGvD,UAAU,CAACuD,GAAG;UACxB,IAAIC,IAAI,GAAGD,GAAG,CAACE,cAAc,CAAC5D,MAAM,CAACmC,SAAS,CAACI,KAAK,CAAC,CAAC;UACtD,IAAImB,GAAG,CAACG,eAAe,EAAE;YACxB,OAAOrD,YAAY,CAACmB,KAAK,CAAC,0CAA0C,CAAC;UACtE;UACA+B,GAAG,CAACI,WAAW,CAACH,IAAI,CAAC;UACrBxD,UAAU,CAAC4D,cAAc,GAAGJ,IAAI;QACjC;QACA;MACD;MACA,IAAIJ,QAAQ,GAAGhB,KAAK,EAAE;QACrB,IAAIyB,UAAU,GAAGhE,MAAM,CAACmC,SAAS,CAACI,KAAK,EAAEgB,QAAQ,CAAC;QAClD,IAAI,CAAC3C,MAAM,IAAI0C,YAAY,CAAC5B,MAAM,KAAK,CAAC,EAAE;UACzCsC,UAAU,GAAGA,UAAU,CAAC5B,OAAO,CAAC,IAAI6B,MAAM,CAACrF,CAAC,CAACsF,KAAK,CAAClE,MAAM,EAAE,GAAG,CAAC,EAAE,EAAE,CAAC;UACpEgE,UAAU,IAAIxD,YAAY,CAACmB,KAAK,CAAC,4CAA4C,GAAGqC,UAAU,GAAG,GAAG,CAAC;QAClG;QACA3B,UAAU,CAACkB,QAAQ,CAAC;MACrB;MACA,QAAQvD,MAAM,CAACiC,MAAM,CAACsB,QAAQ,GAAG,CAAC,CAAC;QAClC,KAAK,GAAG;UACP,IAAIjB,GAAG,GAAGtC,MAAM,CAACc,OAAO,CAAC,GAAG,EAAEyC,QAAQ,GAAG,CAAC,CAAC;UAC3C,IAAIY,UAAU,GAAGnE,MAAM,CAACmC,SAAS,CAACoB,QAAQ,GAAG,CAAC,EAAEjB,GAAG,GAAG,CAAC,GAAGA,GAAG,GAAG8B,SAAS,CAAC;UAC1E,IAAI,CAACD,UAAU,EAAE;YAChB,OAAO3D,YAAY,CAACgD,UAAU,CAAC,sBAAsB,CAAC;UACvD;UACA,IAAIa,YAAY,GAAG/B,GAAG,GAAG,CAAC,IAAI1D,CAAC,CAAC0F,GAAG,CAAC,GAAG,EAAE1F,CAAC,CAAC2F,WAAW,EAAE3F,CAAC,CAACsF,KAAK,EAAE,GAAG,CAAC,CAACpC,IAAI,CAACqC,UAAU,CAAC;UACtF,IAAI,CAACE,YAAY,EAAE;YAClB,OAAO7D,YAAY,CAACgD,UAAU,CAAC,6CAA6C,GAAGW,UAAU,GAAG,GAAG,CAAC;UACjG;UACA,IAAI,CAAChE,UAAU,CAAC4D,cAAc,IAAI,CAAC5D,UAAU,CAACuD,GAAG,CAACG,eAAe,EAAE;YAClE;YACA;YACA;UACD;UACA,IAAIW,cAAc,GACjBlB,YAAY,CAACA,YAAY,CAAC5B,MAAM,GAAG,CAAC,CAAC,IACrCvB,UAAU,CAAC4D,cAAc,CAACU,OAAO,IACjCtE,UAAU,CAACuD,GAAG,CAACG,eAAe,CAACY,OAAO,IACtC,EAAE;UACH,IAAID,cAAc,KAAKH,YAAY,CAAC,CAAC,CAAC,EAAE;YACvC,IAAIK,YAAY,GAAGL,YAAY,CAAC,CAAC,CAAC,CAACM,WAAW,CAAC,CAAC;YAChD,IAAI,CAAC/D,MAAM,IAAI4D,cAAc,CAACG,WAAW,CAAC,CAAC,KAAKD,YAAY,EAAE;cAC7D,OAAOlE,YAAY,CAACgD,UAAU,CAAC,oCAAoC,GAAGgB,cAAc,GAAG,QAAQ,GAAGL,UAAU,GAAG,GAAG,CAAC;YACpH;UACD;UACA,IAAIS,MAAM,GAAGxB,UAAU,CAACyB,GAAG,CAAC,CAAC;UAC7BvB,YAAY,CAACuB,GAAG,CAAC,CAAC;UAClB,IAAIC,UAAU,GAAGF,MAAM,CAACE,UAAU;UAClC3E,UAAU,CAAC4E,UAAU,CAACH,MAAM,CAACI,GAAG,EAAEJ,MAAM,CAACK,SAAS,EAAET,cAAc,CAAC;UACnE,IAAIM,UAAU,EAAE;YACf,KAAK,IAAII,MAAM,IAAIJ,UAAU,EAAE;cAC9B,IAAI7F,MAAM,CAAC6F,UAAU,EAAEI,MAAM,CAAC,EAAE;gBAC/B/E,UAAU,CAACgF,gBAAgB,CAACD,MAAM,CAAC;cACpC;YACD;UACD;UAEA5C,GAAG,EAAE;UACL;QACD;QACA,KAAK,GAAG;UAAE;UACTG,OAAO,IAAIC,QAAQ,CAACa,QAAQ,CAAC;UAC7BjB,GAAG,GAAG8C,0BAA0B,CAACpF,MAAM,EAAEuD,QAAQ,EAAEpD,UAAU,EAAEK,YAAY,CAAC;UAC5E;QACD,KAAK,GAAG;UAAE;UACTiC,OAAO,IAAIC,QAAQ,CAACa,QAAQ,CAAC;UAC7BjB,GAAG,GAAG+C,0BAA0B,CAACrF,MAAM,EAAEuD,QAAQ,EAAEpD,UAAU,EAAEK,YAAY,EAAEI,MAAM,CAAC;UACpF;QACD;UACC6B,OAAO,IAAIC,QAAQ,CAACa,QAAQ,CAAC;UAC7B,IAAI+B,EAAE,GAAG,IAAIC,iBAAiB,CAAC,CAAC;UAChC,IAAIlC,YAAY,GAAGD,UAAU,CAACA,UAAU,CAAC1B,MAAM,GAAG,CAAC,CAAC,CAAC2B,YAAY;UACjE;UACA,IAAIf,GAAG,GAAGkD,qBAAqB,CAACxF,MAAM,EAAEuD,QAAQ,EAAE+B,EAAE,EAAEjC,YAAY,EAAE9B,cAAc,EAAEf,YAAY,EAAEI,MAAM,CAAC;UACzG,IAAI6E,GAAG,GAAGH,EAAE,CAAC5D,MAAM;UAEnB,IAAI,CAAC4D,EAAE,CAACI,MAAM,EAAE;YACf,IAAI9E,MAAM,IAAIlC,WAAW,CAACiH,iBAAiB,CAACL,EAAE,CAACb,OAAO,CAAC,EAAE;cACxDa,EAAE,CAACI,MAAM,GAAG,IAAI;YACjB,CAAC,MAAM;cACNpC,YAAY,CAACsC,IAAI,CAACN,EAAE,CAACb,OAAO,CAAC;YAC9B;UACD;UACA,IAAIhC,OAAO,IAAIgD,GAAG,EAAE;YACnB,IAAII,QAAQ,GAAGC,WAAW,CAACrD,OAAO,EAAE,CAAC,CAAC,CAAC;YACvC;YACA,KAAK,IAAIsD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,GAAG,EAAEM,CAAC,EAAE,EAAE;cAC7B,IAAIvE,CAAC,GAAG8D,EAAE,CAACS,CAAC,CAAC;cACbrD,QAAQ,CAAClB,CAAC,CAACwE,MAAM,CAAC;cAClBxE,CAAC,CAACiB,OAAO,GAAGqD,WAAW,CAACrD,OAAO,EAAE,CAAC,CAAC,CAAC;YACrC;YACAtC,UAAU,CAACsC,OAAO,GAAGoD,QAAQ;YAC7B,IAAII,aAAa,CAACX,EAAE,EAAEnF,UAAU,EAAEkD,YAAY,CAAC,EAAE;cAChDD,UAAU,CAACwC,IAAI,CAACN,EAAE,CAAC;YACpB;YACAnF,UAAU,CAACsC,OAAO,GAAGA,OAAO;UAC7B,CAAC,MAAM;YACN,IAAIwD,aAAa,CAACX,EAAE,EAAEnF,UAAU,EAAEkD,YAAY,CAAC,EAAE;cAChDD,UAAU,CAACwC,IAAI,CAACN,EAAE,CAAC;YACpB;UACD;UAEA,IAAI1E,MAAM,IAAI,CAAC0E,EAAE,CAACI,MAAM,EAAE;YACzBpD,GAAG,GAAG4D,uBAAuB,CAAClG,MAAM,EAAEsC,GAAG,EAAEgD,EAAE,CAACb,OAAO,EAAElD,cAAc,EAAEpB,UAAU,CAAC;UACnF,CAAC,MAAM;YACNmC,GAAG,EAAE;UACN;MACF;IACD,CAAC,CAAC,OAAO6D,CAAC,EAAE;MACX,IAAIA,CAAC,YAAYhH,UAAU,EAAE;QAC5B,MAAMgH,CAAC;MACR,CAAC,MAAM,IAAIA,CAAC,YAAY/G,YAAY,EAAE;QACrC,MAAM,IAAID,UAAU,CAACgH,CAAC,CAACC,IAAI,GAAG,IAAI,GAAGD,CAAC,CAACE,OAAO,EAAElG,UAAU,CAACsC,OAAO,EAAE0D,CAAC,CAAC;MACvE;MACA3F,YAAY,CAACmB,KAAK,CAAC,uBAAuB,GAAGwE,CAAC,CAAC;MAC/C7D,GAAG,GAAG,CAAC,CAAC;IACT;IACA,IAAIA,GAAG,GAAGC,KAAK,EAAE;MAChBA,KAAK,GAAGD,GAAG;IACZ,CAAC,MAAM;MACN;MACAD,UAAU,CAACiE,IAAI,CAACC,GAAG,CAAChD,QAAQ,EAAEhB,KAAK,CAAC,GAAG,CAAC,CAAC;IAC1C;EACD;AACD;AAEA,SAASuD,WAAWA,CAACU,CAAC,EAAEC,CAAC,EAAE;EAC1BA,CAAC,CAACvD,UAAU,GAAGsD,CAAC,CAACtD,UAAU;EAC3BuD,CAAC,CAACtD,YAAY,GAAGqD,CAAC,CAACrD,YAAY;EAC/B,OAAOsD,CAAC;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASjB,qBAAqBA,CAACxF,MAAM,EAAEuC,KAAK,EAAE+C,EAAE,EAAEjC,YAAY,EAAE9B,cAAc,EAAEf,YAAY,EAAEI,MAAM,EAAE;EACrG;AACD;AACA;AACA;AACA;EACC,SAAS8F,YAAYA,CAACC,KAAK,EAAEC,KAAK,EAAEC,UAAU,EAAE;IAC/C,IAAI5H,MAAM,CAACqG,EAAE,CAACwB,cAAc,EAAEH,KAAK,CAAC,EAAE;MACrC,OAAOnG,YAAY,CAACgD,UAAU,CAAC,YAAY,GAAGmD,KAAK,GAAG,YAAY,CAAC;IACpE;IACA,IAAI,CAAC/F,MAAM,IAAIgG,KAAK,CAAC9F,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;MACvC,OAAON,YAAY,CAACgD,UAAU,CAAC,gDAAgD,CAAC;IACjF;IACA8B,EAAE,CAACyB,QAAQ,CACVJ,KAAK;IACL;IACA;IACA;IACA;IACAC,KAAK,CAACxE,OAAO,CAAC,WAAW,EAAE,GAAG,CAAC,CAACA,OAAO,CAAC1B,UAAU,EAAEa,cAAc,CAAC,EACnEsF,UACD,CAAC;EACF;EAEA,IAAIG,QAAQ;EACZ,IAAIJ,KAAK;EACT,IAAI7D,CAAC,GAAG,EAAER,KAAK;EACf,IAAI0E,CAAC,GAAG5H,KAAK,CAAC,CAAC;EACf,OAAO,IAAI,EAAE;IACZ,IAAI6H,CAAC,GAAGlH,MAAM,CAACiC,MAAM,CAACc,CAAC,CAAC;IACxB,QAAQmE,CAAC;MACR,KAAK,GAAG;QACP,IAAID,CAAC,KAAK3H,MAAM,EAAE;UACjB;UACA0H,QAAQ,GAAGhH,MAAM,CAACgC,KAAK,CAACO,KAAK,EAAEQ,CAAC,CAAC;UACjCkE,CAAC,GAAGzH,IAAI;QACT,CAAC,MAAM,IAAIyH,CAAC,KAAK1H,YAAY,EAAE;UAC9B0H,CAAC,GAAGzH,IAAI;QACT,CAAC,MAAM;UACN;UACA,MAAM,IAAI2H,KAAK,CAAC,qCAAqC,CAAC,CAAC,CAAC;QACzD;QACA;MACD,KAAK,GAAG;MACR,KAAK,GAAG;QACP,IACCF,CAAC,KAAKzH,IAAI,IACVyH,CAAC,KAAK3H,MAAM,CAAC;QAAA,EACZ;UACD;UACA,IAAI2H,CAAC,KAAK3H,MAAM,EAAE;YACjBkB,YAAY,CAACQ,OAAO,CAAC,gCAAgC,CAAC;YACtDgG,QAAQ,GAAGhH,MAAM,CAACgC,KAAK,CAACO,KAAK,EAAEQ,CAAC,CAAC;UAClC;UACAR,KAAK,GAAGQ,CAAC,GAAG,CAAC;UACbA,CAAC,GAAG/C,MAAM,CAACc,OAAO,CAACoG,CAAC,EAAE3E,KAAK,CAAC;UAC5B,IAAIQ,CAAC,GAAG,CAAC,EAAE;YACV6D,KAAK,GAAG5G,MAAM,CAACgC,KAAK,CAACO,KAAK,EAAEQ,CAAC,CAAC;YAC9B2D,YAAY,CAACM,QAAQ,EAAEJ,KAAK,EAAErE,KAAK,GAAG,CAAC,CAAC;YACxC0E,CAAC,GAAGvH,UAAU;UACf,CAAC,MAAM;YACN;YACA,MAAM,IAAIyH,KAAK,CAAC,0BAA0B,GAAGD,CAAC,GAAG,SAAS,CAAC;UAC5D;QACD,CAAC,MAAM,IAAID,CAAC,IAAIxH,mBAAmB,EAAE;UACpCmH,KAAK,GAAG5G,MAAM,CAACgC,KAAK,CAACO,KAAK,EAAEQ,CAAC,CAAC;UAC9B2D,YAAY,CAACM,QAAQ,EAAEJ,KAAK,EAAErE,KAAK,CAAC;UACpC/B,YAAY,CAACQ,OAAO,CAAC,aAAa,GAAGgG,QAAQ,GAAG,sBAAsB,GAAGE,CAAC,GAAG,KAAK,CAAC;UACnF3E,KAAK,GAAGQ,CAAC,GAAG,CAAC;UACbkE,CAAC,GAAGvH,UAAU;QACf,CAAC,MAAM;UACN;UACA,MAAM,IAAIyH,KAAK,CAAC,gCAAgC,CAAC,CAAC,CAAC;QACpD;QACA;MACD,KAAK,GAAG;QACP,QAAQF,CAAC;UACR,KAAK5H,KAAK;YACTiG,EAAE,CAAC8B,UAAU,CAACpH,MAAM,CAACgC,KAAK,CAACO,KAAK,EAAEQ,CAAC,CAAC,CAAC;UACtC,KAAKrD,UAAU;UACf,KAAKC,WAAW;UAChB,KAAKC,WAAW;YACfqH,CAAC,GAAGrH,WAAW;YACf0F,EAAE,CAACI,MAAM,GAAG,IAAI;UACjB,KAAKjG,mBAAmB;UACxB,KAAKH,MAAM;YACV;UACD,KAAKC,YAAY;YAChB+F,EAAE,CAACI,MAAM,GAAG,IAAI;YAChB;UACD;UACA;YACC,MAAM,IAAIyB,KAAK,CAAC,mCAAmC,CAAC;UAAE;QACxD;QACA;MACD,KAAK,EAAE;QAAE;QACR3G,YAAY,CAACmB,KAAK,CAAC,yBAAyB,CAAC;QAC7C,IAAIsF,CAAC,IAAI5H,KAAK,EAAE;UACfiG,EAAE,CAAC8B,UAAU,CAACpH,MAAM,CAACgC,KAAK,CAACO,KAAK,EAAEQ,CAAC,CAAC,CAAC;QACtC;QACA,OAAOA,CAAC;MACT,KAAK,GAAG;QACP,QAAQkE,CAAC;UACR,KAAK5H,KAAK;YACTiG,EAAE,CAAC8B,UAAU,CAACpH,MAAM,CAACgC,KAAK,CAACO,KAAK,EAAEQ,CAAC,CAAC,CAAC;UACtC,KAAKrD,UAAU;UACf,KAAKC,WAAW;UAChB,KAAKC,WAAW;YACf;UAAO;UACR,KAAKH,mBAAmB,CAAC,CAAC;UAC1B,KAAKH,MAAM;YACVsH,KAAK,GAAG5G,MAAM,CAACgC,KAAK,CAACO,KAAK,EAAEQ,CAAC,CAAC;YAC9B,IAAI6D,KAAK,CAAC5E,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;cAC5BsD,EAAE,CAACI,MAAM,GAAG,IAAI;cAChBkB,KAAK,GAAGA,KAAK,CAAC5E,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YAC3B;UACD,KAAKzC,YAAY;YAChB,IAAI0H,CAAC,KAAK1H,YAAY,EAAE;cACvBqH,KAAK,GAAGI,QAAQ;YACjB;YACA,IAAIC,CAAC,IAAIxH,mBAAmB,EAAE;cAC7Be,YAAY,CAACQ,OAAO,CAAC,aAAa,GAAG4F,KAAK,GAAG,mBAAmB,CAAC;cACjEF,YAAY,CAACM,QAAQ,EAAEJ,KAAK,EAAErE,KAAK,CAAC;YACrC,CAAC,MAAM;cACN,IAAI,CAAC3B,MAAM,EAAE;gBACZJ,YAAY,CAACQ,OAAO,CAAC,aAAa,GAAG4F,KAAK,GAAG,oBAAoB,GAAGA,KAAK,GAAG,aAAa,CAAC;cAC3F;cACAF,YAAY,CAACE,KAAK,EAAEA,KAAK,EAAErE,KAAK,CAAC;YAClC;YACA;UACD,KAAK/C,IAAI;YACR,IAAI,CAACoB,MAAM,EAAE;cACZ,OAAOJ,YAAY,CAACgD,UAAU,CAAC,4BAA4B,CAAC;YAC7D;QACF;QACA,OAAOT,CAAC;MACT;MACA,KAAK,QAAQ;QACZmE,CAAC,GAAG,GAAG;MACR;QACC,IAAIA,CAAC,IAAI,GAAG,EAAE;UACb;UACA,QAAQD,CAAC;YACR,KAAK5H,KAAK;cACTiG,EAAE,CAAC8B,UAAU,CAACpH,MAAM,CAACgC,KAAK,CAACO,KAAK,EAAEQ,CAAC,CAAC,CAAC,CAAC,CAAC;cACvCkE,CAAC,GAAGtH,WAAW;cACf;YACD,KAAKL,MAAM;cACV0H,QAAQ,GAAGhH,MAAM,CAACgC,KAAK,CAACO,KAAK,EAAEQ,CAAC,CAAC;cACjCkE,CAAC,GAAG1H,YAAY;cAChB;YACD,KAAKE,mBAAmB;cACvB,IAAImH,KAAK,GAAG5G,MAAM,CAACgC,KAAK,CAACO,KAAK,EAAEQ,CAAC,CAAC;cAClCvC,YAAY,CAACQ,OAAO,CAAC,aAAa,GAAG4F,KAAK,GAAG,oBAAoB,CAAC;cAClEF,YAAY,CAACM,QAAQ,EAAEJ,KAAK,EAAErE,KAAK,CAAC;YACrC,KAAK7C,UAAU;cACduH,CAAC,GAAGtH,WAAW;cACf;YACD;YACA;YACA;YACA;YACA;YACA;UACD;QACD,CAAC,MAAM;UACN;UACA;UACA;UACA,QAAQsH,CAAC;YACR;YACA;YACA;YACA,KAAK1H,YAAY;cAChB,IAAI,CAACqB,MAAM,EAAE;gBACZJ,YAAY,CAACQ,OAAO,CAAC,aAAa,GAAGgG,QAAQ,GAAG,oBAAoB,GAAGA,QAAQ,GAAG,cAAc,CAAC;cAClG;cACAN,YAAY,CAACM,QAAQ,EAAEA,QAAQ,EAAEzE,KAAK,CAAC;cACvCA,KAAK,GAAGQ,CAAC;cACTkE,CAAC,GAAG3H,MAAM;cACV;YACD,KAAKI,UAAU;cACdc,YAAY,CAACQ,OAAO,CAAC,8BAA8B,GAAGgG,QAAQ,GAAG,KAAK,CAAC;YACxE,KAAKrH,WAAW;cACfsH,CAAC,GAAG3H,MAAM;cACViD,KAAK,GAAGQ,CAAC;cACT;YACD,KAAKvD,IAAI;cACRyH,CAAC,GAAGxH,mBAAmB;cACvB8C,KAAK,GAAGQ,CAAC;cACT;YACD,KAAKnD,WAAW;cACf,MAAM,IAAIuH,KAAK,CAAC,4DAA4D,CAAC;UAC/E;QACD;IACF,CAAC,CAAC;IACFpE,CAAC,EAAE;EACJ;AACD;;AAEA;AACA;AACA;AACA;AACA,SAASkD,aAAaA,CAACX,EAAE,EAAEnF,UAAU,EAAEkD,YAAY,EAAE;EACpD,IAAIoB,OAAO,GAAGa,EAAE,CAACb,OAAO;EACxB,IAAIK,UAAU,GAAG,IAAI;EACrB,IAAIiB,CAAC,GAAGT,EAAE,CAAC5D,MAAM;EACjB,OAAOqE,CAAC,EAAE,EAAE;IACX,IAAIvE,CAAC,GAAG8D,EAAE,CAACS,CAAC,CAAC;IACb,IAAIsB,KAAK,GAAG7F,CAAC,CAAC6F,KAAK;IACnB,IAAIT,KAAK,GAAGpF,CAAC,CAACoF,KAAK;IACnB,IAAIU,GAAG,GAAGD,KAAK,CAACvG,OAAO,CAAC,GAAG,CAAC;IAC5B,IAAIwG,GAAG,GAAG,CAAC,EAAE;MACZ,IAAIpC,MAAM,GAAI1D,CAAC,CAAC0D,MAAM,GAAGmC,KAAK,CAACrF,KAAK,CAAC,CAAC,EAAEsF,GAAG,CAAE;MAC7C,IAAIrC,SAAS,GAAGoC,KAAK,CAACrF,KAAK,CAACsF,GAAG,GAAG,CAAC,CAAC;MACpC,IAAIC,QAAQ,GAAGrC,MAAM,KAAK,OAAO,IAAID,SAAS;IAC/C,CAAC,MAAM;MACNA,SAAS,GAAGoC,KAAK;MACjBnC,MAAM,GAAG,IAAI;MACbqC,QAAQ,GAAGF,KAAK,KAAK,OAAO,IAAI,EAAE;IACnC;IACA;IACA7F,CAAC,CAACyD,SAAS,GAAGA,SAAS;IACvB;IACA,IAAIsC,QAAQ,KAAK,KAAK,EAAE;MACvB;MACA,IAAIzC,UAAU,IAAI,IAAI,EAAE;QACvBA,UAAU,GAAGxE,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;QAChCF,KAAK,CAACgD,YAAY,EAAGA,YAAY,GAAG/C,MAAM,CAACC,MAAM,CAAC,IAAI,CAAE,CAAC;MAC1D;MACA8C,YAAY,CAACkE,QAAQ,CAAC,GAAGzC,UAAU,CAACyC,QAAQ,CAAC,GAAGX,KAAK;MACrDpF,CAAC,CAACwD,GAAG,GAAG9F,SAAS,CAACsI,KAAK;MACvBrH,UAAU,CAACsH,kBAAkB,CAACF,QAAQ,EAAEX,KAAK,CAAC;IAC/C;EACD;EACA,IAAIb,CAAC,GAAGT,EAAE,CAAC5D,MAAM;EACjB,OAAOqE,CAAC,EAAE,EAAE;IACXvE,CAAC,GAAG8D,EAAE,CAACS,CAAC,CAAC;IACT,IAAIvE,CAAC,CAAC0D,MAAM,EAAE;MACb;MACA,IAAI1D,CAAC,CAAC0D,MAAM,KAAK,KAAK,EAAE;QACvB1D,CAAC,CAACwD,GAAG,GAAG9F,SAAS,CAACwI,GAAG;MACtB;MACA,IAAIlG,CAAC,CAAC0D,MAAM,KAAK,OAAO,EAAE;QACzB1D,CAAC,CAACwD,GAAG,GAAG3B,YAAY,CAAC7B,CAAC,CAAC0D,MAAM,CAAC;MAC/B;IACD;EACD;EACA,IAAIoC,GAAG,GAAG7C,OAAO,CAAC3D,OAAO,CAAC,GAAG,CAAC;EAC9B,IAAIwG,GAAG,GAAG,CAAC,EAAE;IACZpC,MAAM,GAAGI,EAAE,CAACJ,MAAM,GAAGT,OAAO,CAACzC,KAAK,CAAC,CAAC,EAAEsF,GAAG,CAAC;IAC1CrC,SAAS,GAAGK,EAAE,CAACL,SAAS,GAAGR,OAAO,CAACzC,KAAK,CAACsF,GAAG,GAAG,CAAC,CAAC;EAClD,CAAC,MAAM;IACNpC,MAAM,GAAG,IAAI,CAAC,CAAC;IACfD,SAAS,GAAGK,EAAE,CAACL,SAAS,GAAGR,OAAO;EACnC;EACA;EACA,IAAIkD,EAAE,GAAIrC,EAAE,CAACN,GAAG,GAAG3B,YAAY,CAAC6B,MAAM,IAAI,EAAE,CAAE;EAC9C/E,UAAU,CAACyH,YAAY,CAACD,EAAE,EAAE1C,SAAS,EAAER,OAAO,EAAEa,EAAE,CAAC;EACnD;EACA;EACA,IAAIA,EAAE,CAACI,MAAM,EAAE;IACdvF,UAAU,CAAC4E,UAAU,CAAC4C,EAAE,EAAE1C,SAAS,EAAER,OAAO,CAAC;IAC7C,IAAIK,UAAU,EAAE;MACf,KAAKI,MAAM,IAAIJ,UAAU,EAAE;QAC1B,IAAI7F,MAAM,CAAC6F,UAAU,EAAEI,MAAM,CAAC,EAAE;UAC/B/E,UAAU,CAACgF,gBAAgB,CAACD,MAAM,CAAC;QACpC;MACD;IACD;EACD,CAAC,MAAM;IACNI,EAAE,CAACjC,YAAY,GAAGA,YAAY;IAC9BiC,EAAE,CAACR,UAAU,GAAGA,UAAU;IAC1B;IACA,OAAO,IAAI;EACZ;AACD;AAEA,SAASoB,uBAAuBA,CAAClG,MAAM,EAAE6H,UAAU,EAAEpD,OAAO,EAAElD,cAAc,EAAEpB,UAAU,EAAE;EACzF;EACA;EACA;EACA;EACA,IAAI2H,cAAc,GAAGhJ,6BAA6B,CAAC2F,OAAO,CAAC;EAC3D,IAAIqD,cAAc,IAAI9I,oBAAoB,CAACyF,OAAO,CAAC,EAAE;IACpD,IAAIsD,UAAU,GAAG/H,MAAM,CAACc,OAAO,CAAC,IAAI,GAAG2D,OAAO,GAAG,GAAG,EAAEoD,UAAU,CAAC;IACjE,IAAIlE,IAAI,GAAG3D,MAAM,CAACmC,SAAS,CAAC0F,UAAU,GAAG,CAAC,EAAEE,UAAU,CAAC;IAEvD,IAAID,cAAc,EAAE;MACnBnE,IAAI,GAAGA,IAAI,CAACvB,OAAO,CAAC1B,UAAU,EAAEa,cAAc,CAAC;IAChD;IACApB,UAAU,CAACwC,UAAU,CAACgB,IAAI,EAAE,CAAC,EAAEA,IAAI,CAACjC,MAAM,CAAC;IAC3C,OAAOqG,UAAU;EAClB;EACA,OAAOF,UAAU,GAAG,CAAC;AACtB;AAEA,SAASxH,KAAKA,CAACL,MAAM,EAAEgI,MAAM,EAAE;EAC9B,KAAK,IAAIC,CAAC,IAAIjI,MAAM,EAAE;IACrB,IAAIf,MAAM,CAACe,MAAM,EAAEiI,CAAC,CAAC,EAAE;MACtBD,MAAM,CAACC,CAAC,CAAC,GAAGjI,MAAM,CAACiI,CAAC,CAAC;IACtB;EACD;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,UAAUA,CAAClI,MAAM,EAAEuC,KAAK,EAAE;EAClC,IAAIU,KAAK,GAAGV,KAAK;EAEjB,SAAS4F,IAAIA,CAACF,CAAC,EAAE;IAChBA,CAAC,GAAGA,CAAC,IAAI,CAAC;IACV,OAAOjI,MAAM,CAACiC,MAAM,CAACgB,KAAK,GAAGgF,CAAC,CAAC;EAChC;EAEA,SAASG,IAAIA,CAACH,CAAC,EAAE;IAChBA,CAAC,GAAGA,CAAC,IAAI,CAAC;IACVhF,KAAK,IAAIgF,CAAC;EACX;EAEA,SAASI,UAAUA,CAAA,EAAG;IACrB,IAAIC,MAAM,GAAG,CAAC;IACd,OAAOrF,KAAK,GAAGjD,MAAM,CAAC0B,MAAM,EAAE;MAC7B,IAAIwF,CAAC,GAAGiB,IAAI,CAAC,CAAC;MACd,IAAIjB,CAAC,KAAK,GAAG,IAAIA,CAAC,KAAK,IAAI,IAAIA,CAAC,KAAK,IAAI,IAAIA,CAAC,KAAK,IAAI,EAAE;QACxD,OAAOoB,MAAM;MACd;MACAA,MAAM,EAAE;MACRF,IAAI,CAAC,CAAC;IACP;IACA,OAAO,CAAC,CAAC;EACV;EACA,SAASG,kBAAkBA,CAAA,EAAG;IAC7B,OAAOvI,MAAM,CAACmC,SAAS,CAACc,KAAK,CAAC;EAC/B;EACA,SAASuF,mBAAmBA,CAAC7E,IAAI,EAAE;IAClC,OAAO3D,MAAM,CAACmC,SAAS,CAACc,KAAK,EAAEA,KAAK,GAAGU,IAAI,CAACjC,MAAM,CAAC,KAAKiC,IAAI;EAC7D;EACA,SAAS8E,kCAAkCA,CAAC9E,IAAI,EAAE;IACjD,OAAO3D,MAAM,CAACmC,SAAS,CAACc,KAAK,EAAEA,KAAK,GAAGU,IAAI,CAACjC,MAAM,CAAC,CAACgH,WAAW,CAAC,CAAC,KAAK/E,IAAI,CAAC+E,WAAW,CAAC,CAAC;EACzF;EAEA,SAASC,QAAQA,CAACC,IAAI,EAAE;IACvB,IAAIC,IAAI,GAAGjK,CAAC,CAAC0F,GAAG,CAAC,GAAG,EAAEsE,IAAI,CAAC;IAC3B,IAAIhH,KAAK,GAAGiH,IAAI,CAAC/G,IAAI,CAACyG,kBAAkB,CAAC,CAAC,CAAC;IAC3C,IAAI3G,KAAK,EAAE;MACVwG,IAAI,CAACxG,KAAK,CAAC,CAAC,CAAC,CAACF,MAAM,CAAC;MACrB,OAAOE,KAAK,CAAC,CAAC,CAAC;IAChB;IACA,OAAO,IAAI;EACZ;EACA,OAAO;IACNuG,IAAI,EAAEA,IAAI;IACVW,QAAQ,EAAE,SAAAA,CAAA,EAAY;MACrB,OAAO7F,KAAK;IACb,CAAC;IACD0F,QAAQ,EAAEA,QAAQ;IAClBI,SAAS,EAAE,SAAAA,CAAA,EAAY;MACtB,OAAO/I,MAAM;IACd,CAAC;IACDoI,IAAI,EAAEA,IAAI;IACVC,UAAU,EAAEA,UAAU;IACtBE,kBAAkB,EAAEA,kBAAkB;IACtCC,mBAAmB,EAAEA,mBAAmB;IACxCC,kCAAkC,EAAEA;EACrC,CAAC;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASO,0BAA0BA,CAACjG,CAAC,EAAEvC,YAAY,EAAE;EACpD;AACD;AACA;AACA;AACA;EACC,SAASyI,OAAOA,CAAClG,CAAC,EAAEvC,YAAY,EAAE;IACjC,IAAIoB,KAAK,GAAGhD,CAAC,CAACsK,EAAE,CAACpH,IAAI,CAACiB,CAAC,CAACwF,kBAAkB,CAAC,CAAC,CAAC;IAC7C,IAAI,CAAC3G,KAAK,EAAE;MACX,OAAOpB,YAAY,CAACgD,UAAU,CAAC,wDAAwD,GAAGT,CAAC,CAAC+F,QAAQ,CAAC,CAAC,CAAC;IACxG;IACA,IAAIlH,KAAK,CAAC,CAAC,CAAC,CAAC+C,WAAW,CAAC,CAAC,KAAK,KAAK,EAAE;MACrC,OAAOnE,YAAY,CAACgD,UAAU,CAC7B,sFAAsF,GAAGT,CAAC,CAAC+F,QAAQ,CAAC,CACrG,CAAC;IACF;IACA/F,CAAC,CAACqF,IAAI,CAACxG,KAAK,CAAC,CAAC,CAAC,CAACF,MAAM,CAAC;IACvB,OAAOE,KAAK,CAAC,CAAC,CAAC;EAChB;EACA;EACA,IAAI5B,MAAM,GAAG+C,CAAC,CAACgG,SAAS,CAAC,CAAC;EAC1B,IAAIhG,CAAC,CAACoF,IAAI,CAAC,CAAC,KAAK,GAAG,EAAE;IACrBpF,CAAC,CAACqF,IAAI,CAAC,CAAC,CAAC;IACT,IAAIe,cAAc,GAAGpG,CAAC,CAAC+F,QAAQ,CAAC,CAAC;IACjC,OAAO/F,CAAC,CAAC+F,QAAQ,CAAC,CAAC,GAAG9I,MAAM,CAAC0B,MAAM,EAAE;MACpCqB,CAAC,CAACsF,UAAU,CAAC,CAAC;MACd,IAAItF,CAAC,CAACoF,IAAI,CAAC,CAAC,KAAK,GAAG,EAAE;QACrB,IAAIiB,cAAc,GAAGpJ,MAAM,CAACmC,SAAS,CAACgH,cAAc,EAAEpG,CAAC,CAAC+F,QAAQ,CAAC,CAAC,CAAC;QACnE/F,CAAC,CAACqF,IAAI,CAAC,CAAC,CAAC;QACT,OAAOgB,cAAc;MACtB;MACA,IAAIC,OAAO,GAAG,IAAI;MAClB;MACA;MACA;MACA;MACA,IAAItG,CAAC,CAACoF,IAAI,CAAC,CAAC,KAAK,GAAG,IAAIpF,CAAC,CAACoF,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAC1C,QAAQpF,CAAC,CAACoF,IAAI,CAAC,CAAC,CAAC;UAChB,KAAK,GAAG;YAAE;YACT,IAAIpF,CAAC,CAACoF,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;cACtBkB,OAAO,GAAGtG,CAAC,CAAC4F,QAAQ,CAAC/J,CAAC,CAAC0K,WAAW,CAAC;YACpC,CAAC,MAAM,IAAIvG,CAAC,CAACoF,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;cAC7BkB,OAAO,GAAGtG,CAAC,CAAC4F,QAAQ,CAAC/J,CAAC,CAAC2K,UAAU,CAAC;YACnC;YACA;UACD,KAAK,GAAG;YAAE;YACTF,OAAO,GAAGtG,CAAC,CAAC4F,QAAQ,CAAC/J,CAAC,CAAC4K,WAAW,CAAC;YACnC;UACD,KAAK,GAAG;YAAE;YACTH,OAAO,GAAGtG,CAAC,CAAC4F,QAAQ,CAAC/J,CAAC,CAAC6K,YAAY,CAAC;YACpC;UACD,KAAK,GAAG;YAAE;YACTJ,OAAO,GAAGtG,CAAC,CAAC4F,QAAQ,CAAC/J,CAAC,CAAC8K,OAAO,CAAC;YAC/B;QACF;MACD,CAAC,MAAM,IAAI3G,CAAC,CAACoF,IAAI,CAAC,CAAC,KAAK,GAAG,IAAIpF,CAAC,CAACoF,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QACjDkB,OAAO,GAAGJ,OAAO,CAAClG,CAAC,EAAEvC,YAAY,CAAC;MACnC,CAAC,MAAM,IAAIuC,CAAC,CAACoF,IAAI,CAAC,CAAC,KAAK,GAAG,EAAE;QAC5BkB,OAAO,GAAGtG,CAAC,CAAC4F,QAAQ,CAAC/J,CAAC,CAAC+K,WAAW,CAAC;MACpC,CAAC,MAAM;QACN,OAAOnJ,YAAY,CAACgD,UAAU,CAAC,sCAAsC,CAAC;MACvE;MACA,IAAI,CAAC6F,OAAO,EAAE;QACb,OAAO7I,YAAY,CAACgD,UAAU,CAAC,uCAAuC,GAAGT,CAAC,CAAC+F,QAAQ,CAAC,CAAC,CAAC;MACvF;IACD;IACA,OAAOtI,YAAY,CAACgD,UAAU,CAAC,uDAAuD,CAAC;EACxF;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS6B,0BAA0BA,CAACrF,MAAM,EAAEuC,KAAK,EAAEpC,UAAU,EAAEK,YAAY,EAAEI,MAAM,EAAE;EACpF,IAAImC,CAAC,GAAGmF,UAAU,CAAClI,MAAM,EAAEuC,KAAK,CAAC;EAEjC,QAAQ3B,MAAM,GAAGmC,CAAC,CAACoF,IAAI,CAAC,CAAC,CAAC,CAACO,WAAW,CAAC,CAAC,GAAG3F,CAAC,CAACoF,IAAI,CAAC,CAAC,CAAC;IACnD,KAAK,GAAG;MACP;MACA,IAAIyB,OAAO,GAAG7G,CAAC,CAAC4F,QAAQ,CAAC/J,CAAC,CAAC8K,OAAO,CAAC;MACnC,IAAIE,OAAO,EAAE;QACZzJ,UAAU,CAACyJ,OAAO,CAACA,OAAO,EAAEhL,CAAC,CAACiL,aAAa,CAACnI,MAAM,EAAEkI,OAAO,CAAClI,MAAM,GAAG9C,CAAC,CAACiL,aAAa,CAACnI,MAAM,GAAG9C,CAAC,CAACkL,WAAW,CAACpI,MAAM,CAAC;QACnH,OAAOqB,CAAC,CAAC+F,QAAQ,CAAC,CAAC;MACpB,CAAC,MAAM;QACN,OAAOtI,YAAY,CAACgD,UAAU,CAAC,yCAAyC,GAAGT,CAAC,CAAC+F,QAAQ,CAAC,CAAC,CAAC;MACzF;IACD,KAAK,GAAG;MACP;MACA,IAAIiB,KAAK,GAAGhH,CAAC,CAAC4F,QAAQ,CAAC/J,CAAC,CAACoL,MAAM,CAAC;MAChC,IAAID,KAAK,EAAE;QACV,IAAI,CAACnJ,MAAM,IAAI,CAACT,UAAU,CAAC4D,cAAc,EAAE;UAC1C,OAAOvD,YAAY,CAACgD,UAAU,CAAC,0BAA0B,CAAC;QAC3D;QACArD,UAAU,CAAC8J,UAAU,CAAC,CAAC;QACvB9J,UAAU,CAACwC,UAAU,CAACoH,KAAK,EAAEnL,CAAC,CAACsL,WAAW,CAACxI,MAAM,EAAEqI,KAAK,CAACrI,MAAM,GAAG9C,CAAC,CAACsL,WAAW,CAACxI,MAAM,GAAG9C,CAAC,CAACuL,SAAS,CAACzI,MAAM,CAAC;QAC5GvB,UAAU,CAACiK,QAAQ,CAAC,CAAC;QACrB,OAAOrH,CAAC,CAAC+F,QAAQ,CAAC,CAAC;MACpB,CAAC,MAAM;QACN,OAAOtI,YAAY,CAACgD,UAAU,CAAC,qCAAqC,GAAGjB,KAAK,CAAC;MAC9E;IACD,KAAK,GAAG;MAAE;QACT;QACA,IAAIpC,UAAU,CAACuD,GAAG,IAAIvD,UAAU,CAACuD,GAAG,CAACG,eAAe,EAAE;UACrD,OAAOrD,YAAY,CAACgD,UAAU,CAAC,kEAAkE,GAAGT,CAAC,CAAC+F,QAAQ,CAAC,CAAC,CAAC;QAClH;QACA,IAAIlI,MAAM,GAAG,CAACmC,CAAC,CAAC0F,kCAAkC,CAAC7J,CAAC,CAACyL,kBAAkB,CAAC,GAAG,CAACtH,CAAC,CAACyF,mBAAmB,CAAC5J,CAAC,CAACyL,kBAAkB,CAAC,EAAE;UACxH,OAAO7J,YAAY,CAACgD,UAAU,CAAC,WAAW,GAAG5E,CAAC,CAACyL,kBAAkB,GAAG,eAAe,GAAGtH,CAAC,CAAC+F,QAAQ,CAAC,CAAC,CAAC;QACpG;QACA/F,CAAC,CAACqF,IAAI,CAACxJ,CAAC,CAACyL,kBAAkB,CAAC3I,MAAM,CAAC;QACnC,IAAIqB,CAAC,CAACsF,UAAU,CAAC,CAAC,GAAG,CAAC,EAAE;UACvB,OAAO7H,YAAY,CAACgD,UAAU,CAAC,4BAA4B,GAAG5E,CAAC,CAACyL,kBAAkB,GAAG,eAAe,GAAGtH,CAAC,CAAC+F,QAAQ,CAAC,CAAC,CAAC;QACrH;QAEA,IAAIwB,OAAO,GAAG;UACblE,IAAI,EAAEhC,SAAS;UACfmG,QAAQ,EAAEnG,SAAS;UACnBoG,QAAQ,EAAEpG,SAAS;UACnBgF,cAAc,EAAEhF;QACjB,CAAC;QACD;QACAkG,OAAO,CAAClE,IAAI,GAAGrD,CAAC,CAAC4F,QAAQ,CAAC/J,CAAC,CAAC6L,IAAI,CAAC;QACjC,IAAI,CAACH,OAAO,CAAClE,IAAI,EAChB,OAAO5F,YAAY,CAACgD,UAAU,CAAC,qEAAqE,GAAGT,CAAC,CAAC+F,QAAQ,CAAC,CAAC,CAAC;QAErH,IAAIlI,MAAM,IAAI0J,OAAO,CAAClE,IAAI,CAACzB,WAAW,CAAC,CAAC,KAAK,MAAM,EAAE;UACpDnE,YAAY,CAACQ,OAAO,CAAC,kDAAkD,GAAG+B,CAAC,CAAC+F,QAAQ,CAAC,CAAC,CAAC;QACxF;QACA/F,CAAC,CAACsF,UAAU,CAAC,CAAC;;QAEd;QACA,IAAItF,CAAC,CAACyF,mBAAmB,CAAC5J,CAAC,CAAC8L,MAAM,CAAC,IAAI3H,CAAC,CAACyF,mBAAmB,CAAC5J,CAAC,CAAC+L,MAAM,CAAC,EAAE;UACvE,IAAI/I,KAAK,GAAGhD,CAAC,CAACgM,gBAAgB,CAAC9I,IAAI,CAACiB,CAAC,CAACwF,kBAAkB,CAAC,CAAC,CAAC;UAC3D,IAAI,CAAC3G,KAAK,EAAE;YACX,OAAOpB,YAAY,CAACgD,UAAU,CAAC,qDAAqD,GAAGT,CAAC,CAAC+F,QAAQ,CAAC,CAAC,CAAC;UACrG;UACA,IAAIlH,KAAK,CAACiJ,MAAM,CAACC,iBAAiB,KAAK1G,SAAS,EAAE;YACjDkG,OAAO,CAACE,QAAQ,GAAG5I,KAAK,CAACiJ,MAAM,CAACC,iBAAiB;UAClD,CAAC,MAAM;YACNR,OAAO,CAACE,QAAQ,GAAG5I,KAAK,CAACiJ,MAAM,CAACE,aAAa;YAC7CT,OAAO,CAACC,QAAQ,GAAG3I,KAAK,CAACiJ,MAAM,CAACG,YAAY;UAC7C;UACAjI,CAAC,CAACqF,IAAI,CAACxG,KAAK,CAAC,CAAC,CAAC,CAACF,MAAM,CAAC;QACxB,CAAC,MAAM,IAAId,MAAM,IAAImC,CAAC,CAAC0F,kCAAkC,CAAC7J,CAAC,CAAC+L,MAAM,CAAC,EAAE;UACpE;UACA5H,CAAC,CAACqF,IAAI,CAACxJ,CAAC,CAAC+L,MAAM,CAACjJ,MAAM,CAAC;UACvB,IAAIqB,CAAC,CAACsF,UAAU,CAAC,CAAC,GAAG,CAAC,EAAE;YACvB,OAAO7H,YAAY,CAACgD,UAAU,CAAC,4BAA4B,GAAG5E,CAAC,CAAC+L,MAAM,GAAG,eAAe,GAAG5H,CAAC,CAAC+F,QAAQ,CAAC,CAAC,CAAC;UACzG;UACAwB,OAAO,CAACE,QAAQ,GAAGzH,CAAC,CAAC4F,QAAQ,CAAC/J,CAAC,CAACqM,iCAAiC,CAAC;UAClE,IAAI,CAACX,OAAO,CAACE,QAAQ,EAAE;YACtB,OAAOhK,YAAY,CAACgD,UAAU,CAC7B,WAAW,GAAG5E,CAAC,CAACsM,mBAAmB,GAAG,oCAAoC,GAAGtM,CAAC,CAAC+L,MAAM,GAAG,eAAe,GAAG5H,CAAC,CAAC+F,QAAQ,CAAC,CACtH,CAAC;UACF;QACD;QACA,IAAIlI,MAAM,IAAI0J,OAAO,CAACE,QAAQ,IAAI,CAAC5L,CAAC,CAACqM,iCAAiC,CAACE,IAAI,CAACb,OAAO,CAACE,QAAQ,CAAC,EAAE;UAC9FhK,YAAY,CAACQ,OAAO,CAAC,2DAA2D,GAAG+B,CAAC,CAAC+F,QAAQ,CAAC,CAAC,CAAC;QACjG;QACA,IAAI,CAAClI,MAAM,EAAE;UACZmC,CAAC,CAACsF,UAAU,CAAC,CAAC;UACdiC,OAAO,CAAClB,cAAc,GAAGJ,0BAA0B,CAACjG,CAAC,EAAEvC,YAAY,CAAC;QACrE;QACAuC,CAAC,CAACsF,UAAU,CAAC,CAAC;QACd,IAAItF,CAAC,CAACoF,IAAI,CAAC,CAAC,KAAK,GAAG,EAAE;UACrB,OAAO3H,YAAY,CAACgD,UAAU,CAAC,4CAA4C,GAAGT,CAAC,CAAC+F,QAAQ,CAAC,CAAC,CAAC;QAC5F;QACA/F,CAAC,CAACqF,IAAI,CAAC,CAAC,CAAC;QACTjI,UAAU,CAACiL,QAAQ,CAACd,OAAO,CAAClE,IAAI,EAAEkE,OAAO,CAACC,QAAQ,EAAED,OAAO,CAACE,QAAQ,EAAEF,OAAO,CAAClB,cAAc,CAAC;QAC7FjJ,UAAU,CAACkL,MAAM,CAAC,CAAC;QACnB,OAAOtI,CAAC,CAAC+F,QAAQ,CAAC,CAAC;MACpB;IACA;MACC,OAAOtI,YAAY,CAACgD,UAAU,CAAC,qDAAqD,GAAGjB,KAAK,CAAC;EAC/F;AACD;AAEA,SAAS6C,0BAA0BA,CAACpF,MAAM,EAAEuC,KAAK,EAAEpC,UAAU,EAAEK,YAAY,EAAE;EAC5E,IAAIoB,KAAK,GAAG5B,MAAM,CAACmC,SAAS,CAACI,KAAK,CAAC,CAACX,KAAK,CAAChD,CAAC,CAACsK,EAAE,CAAC;EAC/C,IAAI,CAACtH,KAAK,EAAE;IACX,OAAOpB,YAAY,CAACgD,UAAU,CAAC,sDAAsD,GAAGjB,KAAK,CAAC;EAC/F;EACA,IAAIX,KAAK,CAAC,CAAC,CAAC,CAAC+C,WAAW,CAAC,CAAC,KAAK,KAAK,EAAE;IACrC,IAAIpC,KAAK,GAAG,CAAC,EAAE;MACd,OAAO/B,YAAY,CAACgD,UAAU,CAC7B,qCAAqC,GAAGjB,KAAK,GAAG,mEACjD,CAAC;IACF;IACA,IAAI,CAAC3D,CAAC,CAAC0M,OAAO,CAACH,IAAI,CAACnL,MAAM,CAACmC,SAAS,CAACI,KAAK,CAAC,CAAC,EAAE;MAC7C,OAAO/B,YAAY,CAACgD,UAAU,CAAC,oCAAoC,CAAC;IACrE;EACD;EACArD,UAAU,CAACoL,qBAAqB,CAAC3J,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,CAAC;EACpD,OAAOW,KAAK,GAAGX,KAAK,CAAC,CAAC,CAAC,CAACF,MAAM;AAC/B;AAEA,SAAS6D,iBAAiBA,CAAA,EAAG;EAC5B,IAAI,CAACuB,cAAc,GAAGxG,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;AAC1C;AAEAgF,iBAAiB,CAACzF,SAAS,GAAG;EAC7BsH,UAAU,EAAE,SAAAA,CAAU3C,OAAO,EAAE;IAC9B,IAAI,CAAC7F,CAAC,CAAC4M,WAAW,CAACL,IAAI,CAAC1G,OAAO,CAAC,EAAE;MACjC,MAAM,IAAI0C,KAAK,CAAC,kBAAkB,GAAG1C,OAAO,CAAC;IAC9C;IACA,IAAI,CAACA,OAAO,GAAGA,OAAO;EACvB,CAAC;EACDsC,QAAQ,EAAE,SAAAA,CAAUM,KAAK,EAAET,KAAK,EAAEZ,MAAM,EAAE;IACzC,IAAI,CAACpH,CAAC,CAAC4M,WAAW,CAACL,IAAI,CAAC9D,KAAK,CAAC,EAAE;MAC/B,MAAM,IAAIF,KAAK,CAAC,oBAAoB,GAAGE,KAAK,CAAC;IAC9C;IACA,IAAI,CAACP,cAAc,CAACO,KAAK,CAAC,GAAG,IAAI,CAAC3F,MAAM;IACxC,IAAI,CAAC,IAAI,CAACA,MAAM,EAAE,CAAC,GAAG;MAAE2F,KAAK,EAAEA,KAAK;MAAET,KAAK,EAAEA,KAAK;MAAEZ,MAAM,EAAEA;IAAO,CAAC;EACrE,CAAC;EACDtE,MAAM,EAAE,CAAC;EACT+J,YAAY,EAAE,SAAAA,CAAU1F,CAAC,EAAE;IAC1B,OAAO,IAAI,CAACA,CAAC,CAAC,CAACd,SAAS;EACzB,CAAC;EACDyG,UAAU,EAAE,SAAAA,CAAU3F,CAAC,EAAE;IACxB,OAAO,IAAI,CAACA,CAAC,CAAC,CAACtD,OAAO;EACvB,CAAC;EACDkJ,QAAQ,EAAE,SAAAA,CAAU5F,CAAC,EAAE;IACtB,OAAO,IAAI,CAACA,CAAC,CAAC,CAACsB,KAAK;EACrB,CAAC;EACDuE,MAAM,EAAE,SAAAA,CAAU7F,CAAC,EAAE;IACpB,OAAO,IAAI,CAACA,CAAC,CAAC,CAACf,GAAG;EACnB,CAAC;EACD6G,QAAQ,EAAE,SAAAA,CAAU9F,CAAC,EAAE;IACtB,OAAO,IAAI,CAACA,CAAC,CAAC,CAACa,KAAK;EACrB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACD,CAAC;AAEDkF,OAAO,CAACjM,SAAS,GAAGA,SAAS;AAC7BiM,OAAO,CAAC5D,UAAU,GAAGA,UAAU;AAC/B4D,OAAO,CAACzG,0BAA0B,GAAGA,0BAA0B","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}