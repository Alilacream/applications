{"ast":null,"code":"\"use strict\";\n\nfunction _createForOfIteratorHelper(r, e) {\n  var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (!t) {\n    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) {\n      t && (r = t);\n      var _n = 0,\n        F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          return _n >= r.length ? {\n            done: !0\n          } : {\n            done: !1,\n            value: r[_n++]\n          };\n        },\n        e: function e(r) {\n          throw r;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var o,\n    a = !0,\n    u = !1;\n  return {\n    s: function s() {\n      t = t.call(r);\n    },\n    n: function n() {\n      var r = t.next();\n      return a = r.done, r;\n    },\n    e: function e(r) {\n      u = !0, o = r;\n    },\n    f: function f() {\n      try {\n        a || null == t[\"return\"] || t[\"return\"]();\n      } finally {\n        if (u) throw o;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n  }\n}\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nvar support = require(\"./support.js\");\nvar utils = require(\"./utils.js\");\nvar _crc = require(\"./crc32.js\");\nvar signature = require(\"./signature.js\");\nvar defaults = require(\"./defaults.js\");\nvar base64 = require(\"./base64.js\");\nvar compressions = require(\"./compressions.js\");\nvar CompressedObject = require(\"./compressedObject.js\");\nvar nodeBuffer = require(\"./nodeBuffer.js\");\nvar utf8 = require(\"./utf8.js\");\nvar StringWriter = require(\"./stringWriter.js\");\nvar Uint8ArrayWriter = require(\"./uint8ArrayWriter.js\");\n\n/**\n * Returns the raw data of a ZipObject, decompress the content if necessary.\n * @param {ZipObject} file the file to use.\n * @return {String|ArrayBuffer|Uint8Array|Buffer} the data.\n */\nfunction getRawData(file) {\n  if (file._data instanceof CompressedObject) {\n    file._data = file._data.getContent();\n    file.options.binary = true;\n    file.options.base64 = false;\n    if (utils.getTypeOf(file._data) === \"uint8array\") {\n      var copy = file._data;\n      // when reading an arraybuffer, the CompressedObject mechanism will keep it and subarray() a Uint8Array.\n      // if we request a file in the same format, we might get the same Uint8Array or its ArrayBuffer (the original zip file).\n      file._data = new Uint8Array(copy.length);\n      // with an empty Uint8Array, Opera fails with a \"Offset larger than array size\"\n      if (copy.length !== 0) {\n        file._data.set(copy, 0);\n      }\n    }\n  }\n  return file._data;\n}\n\n/**\n * Returns the data of a ZipObject in a binary form. If the content is an unicode string, encode it.\n * @param {ZipObject} file the file to use.\n * @return {String|ArrayBuffer|Uint8Array|Buffer} the data.\n */\nfunction getBinaryData(file) {\n  var result = getRawData(file),\n    type = utils.getTypeOf(result);\n  if (type === \"string\") {\n    if (!file.options.binary) {\n      // unicode text !\n      // unicode string => binary string is a painful process, check if we can avoid it.\n      if (support.nodebuffer) {\n        return nodeBuffer(result, \"utf-8\");\n      }\n    }\n    return file.asBinary();\n  }\n  return result;\n}\n\n// return the actual prototype of PizZip\nvar out = {\n  /**\n   * Read an existing zip and merge the data in the current PizZip object.\n   * The implementation is in pizzip-load.js, don't forget to include it.\n   * @param {String|ArrayBuffer|Uint8Array|Buffer} stream  The stream to load\n   * @param {Object} options Options for loading the stream.\n   *  options.base64 : is the stream in base64 ? default : false\n   * @return {PizZip} the current PizZip object\n   */\n  load: function load() {\n    throw new Error(\"Load method is not defined. Is the file pizzip-load.js included ?\");\n  },\n  /**\n   * Filter nested files/folders with the specified function.\n   * @param {Function} search the predicate to use :\n   * function (relativePath, file) {...}\n   * It takes 2 arguments : the relative path and the file.\n   * @return {Array} An array of matching elements.\n   */\n  filter: function filter(search) {\n    var result = [];\n    var filename, relativePath, file, fileClone;\n    for (filename in this.files) {\n      if (!this.files.hasOwnProperty(filename)) {\n        continue;\n      }\n      file = this.files[filename];\n      // return a new object, don't let the user mess with our internal objects :)\n      fileClone = new ZipObject(file.name, file._data, utils.extend(file.options));\n      relativePath = filename.slice(this.root.length, filename.length);\n      if (filename.slice(0, this.root.length) === this.root &&\n      // the file is in the current root\n      search(relativePath, fileClone)) {\n        // and the file matches the function\n        result.push(fileClone);\n      }\n    }\n    return result;\n  },\n  /**\n   * Add a file to the zip file, or search a file.\n   * @param   {string|RegExp} name The name of the file to add (if data is defined),\n   * the name of the file to find (if no data) or a regex to match files.\n   * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded\n   * @param   {Object} o     File options\n   * @return  {PizZip|Object|Array} this PizZip object (when adding a file),\n   * a file (when searching by string) or an array of files (when searching by regex).\n   */\n  file: function file(name, data, o) {\n    if (arguments.length === 1) {\n      if (utils.isRegExp(name)) {\n        var regexp = name;\n        return this.filter(function (relativePath, file) {\n          return !file.dir && regexp.test(relativePath);\n        });\n      }\n      // text\n      return this.filter(function (relativePath, file) {\n        return !file.dir && relativePath === name;\n      })[0] || null;\n    }\n    // more than one argument : we have data !\n    name = this.root + name;\n    fileAdd.call(this, name, data, o);\n    return this;\n  },\n  /**\n   * Add a directory to the zip file, or search.\n   * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.\n   * @return  {PizZip} an object with the new directory as the root, or an array containing matching folders.\n   */\n  folder: function folder(arg) {\n    if (!arg) {\n      return this;\n    }\n    if (utils.isRegExp(arg)) {\n      return this.filter(function (relativePath, file) {\n        return file.dir && arg.test(relativePath);\n      });\n    }\n\n    // else, name is a new folder\n    var name = this.root + arg;\n    var newFolder = folderAdd.call(this, name);\n\n    // Allow chaining by returning a new object with this folder as the root\n    var ret = this.shallowClone();\n    ret.root = newFolder.name;\n    return ret;\n  },\n  /**\n   * Delete a file, or a directory and all sub-files, from the zip\n   * @param {string} name the name of the file to delete\n   * @return {PizZip} this PizZip object\n   */\n  remove: function remove(name) {\n    name = this.root + name;\n    var file = this.files[name];\n    if (!file) {\n      // Look for any folders\n      if (name.slice(-1) !== \"/\") {\n        name += \"/\";\n      }\n      file = this.files[name];\n    }\n    if (file && !file.dir) {\n      // file\n      delete this.files[name];\n    } else {\n      // maybe a folder, delete recursively\n      var kids = this.filter(function (relativePath, file) {\n        return file.name.slice(0, name.length) === name;\n      });\n      for (var i = 0; i < kids.length; i++) {\n        delete this.files[kids[i].name];\n      }\n    }\n    return this;\n  },\n  /**\n   * Generate the complete zip file\n   * @param {Object} options the options to generate the zip file :\n   * - base64, (deprecated, use type instead) true to generate base64.\n   * - compression, \"STORE\" by default.\n   * - type, \"base64\" by default. Values are : string, base64, uint8array, arraybuffer, blob.\n   * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file\n   */\n  generate: function generate(options) {\n    options = utils.extend(options || {}, {\n      base64: true,\n      compression: \"STORE\",\n      compressionOptions: null,\n      type: \"base64\",\n      platform: \"DOS\",\n      comment: null,\n      mimeType: \"application/zip\",\n      encodeFileName: utf8.utf8encode\n    });\n    utils.checkSupport(options.type);\n\n    // accept nodejs `process.platform`\n    if (options.platform === \"darwin\" || options.platform === \"freebsd\" || options.platform === \"linux\" || options.platform === \"sunos\") {\n      options.platform = \"UNIX\";\n    }\n    if (options.platform === \"win32\") {\n      options.platform = \"DOS\";\n    }\n    var zipData = [],\n      encodedComment = utils.transformTo(\"string\", options.encodeFileName(options.comment || this.comment || \"\"));\n    var localDirLength = 0,\n      centralDirLength = 0,\n      writer,\n      i;\n    var fileNames = [];\n    if (options.fileOrder instanceof Array) {\n      fileNames = options.fileOrder;\n    }\n    for (var name in this.files) {\n      if (fileNames.indexOf(name) === -1) {\n        fileNames.push(name);\n      }\n    }\n    if (typeof options.fileOrder === \"function\") {\n      fileNames = options.fileOrder(this.files);\n    }\n\n    // first, generate all the zip parts.\n    var _iterator = _createForOfIteratorHelper(fileNames),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _name = _step.value;\n        if (!this.files.hasOwnProperty(_name)) {\n          continue;\n        }\n        var file = this.files[_name];\n        var compressionName = file.options.compression || options.compression.toUpperCase();\n        var compression = compressions[compressionName];\n        if (!compression) {\n          throw new Error(compressionName + \" is not a valid compression method !\");\n        }\n        var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};\n        var compressedObject = generateCompressedObjectFrom.call(this, file, compression, compressionOptions);\n        var zipPart = generateZipParts.call(this, _name, file, compressedObject, localDirLength, options.platform, options.encodeFileName);\n        localDirLength += zipPart.fileRecord.length + compressedObject.compressedSize;\n        centralDirLength += zipPart.dirRecord.length;\n        zipData.push(zipPart);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var dirEnd = \"\";\n\n    // end of central dir signature\n    dirEnd = signature.CENTRAL_DIRECTORY_END +\n    // number of this disk\n    \"\\x00\\x00\" +\n    // number of the disk with the start of the central directory\n    \"\\x00\\x00\" +\n    // total number of entries in the central directory on this disk\n    decToHex(zipData.length, 2) +\n    // total number of entries in the central directory\n    decToHex(zipData.length, 2) +\n    // size of the central directory   4 bytes\n    decToHex(centralDirLength, 4) +\n    // offset of start of central directory with respect to the starting disk number\n    decToHex(localDirLength, 4) +\n    // .ZIP file comment length\n    decToHex(encodedComment.length, 2) +\n    // .ZIP file comment\n    encodedComment;\n\n    // we have all the parts (and the total length)\n    // time to create a writer !\n    var typeName = options.type.toLowerCase();\n    if (typeName === \"uint8array\" || typeName === \"arraybuffer\" || typeName === \"blob\" || typeName === \"nodebuffer\") {\n      writer = new Uint8ArrayWriter(localDirLength + centralDirLength + dirEnd.length);\n    } else {\n      writer = new StringWriter(localDirLength + centralDirLength + dirEnd.length);\n    }\n    for (i = 0; i < zipData.length; i++) {\n      writer.append(zipData[i].fileRecord);\n      writer.append(zipData[i].compressedObject.compressedContent);\n    }\n    for (i = 0; i < zipData.length; i++) {\n      writer.append(zipData[i].dirRecord);\n    }\n    writer.append(dirEnd);\n    var zip = writer.finalize();\n    switch (options.type.toLowerCase()) {\n      // case \"zip is an Uint8Array\"\n      case \"uint8array\":\n      case \"arraybuffer\":\n      case \"nodebuffer\":\n        return utils.transformTo(options.type.toLowerCase(), zip);\n      case \"blob\":\n        return utils.arrayBuffer2Blob(utils.transformTo(\"arraybuffer\", zip), options.mimeType);\n      // case \"zip is a string\"\n      case \"base64\":\n        return options.base64 ? base64.encode(zip) : zip;\n      default:\n        // case \"string\" :\n        return zip;\n    }\n  },\n  /**\n   * @deprecated\n   * This method will be removed in a future version without replacement.\n   */\n  crc32: function crc32(input, crc) {\n    return _crc(input, crc);\n  },\n  /**\n   * @deprecated\n   * This method will be removed in a future version without replacement.\n   */\n  utf8encode: function utf8encode(string) {\n    return utils.transformTo(\"string\", utf8.utf8encode(string));\n  },\n  /**\n   * @deprecated\n   * This method will be removed in a future version without replacement.\n   */\n  utf8decode: function utf8decode(input) {\n    return utf8.utf8decode(input);\n  }\n};\n/**\n * Transform this._data into a string.\n * @param {function} filter a function String -> String, applied if not null on the result.\n * @return {String} the string representing this._data.\n */\nfunction dataToString(asUTF8) {\n  var result = getRawData(this);\n  if (result === null || typeof result === \"undefined\") {\n    return \"\";\n  }\n  // if the data is a base64 string, we decode it before checking the encoding !\n  if (this.options.base64) {\n    result = base64.decode(result);\n  }\n  if (asUTF8 && this.options.binary) {\n    // PizZip.prototype.utf8decode supports arrays as input\n    // skip to array => string step, utf8decode will do it.\n    result = out.utf8decode(result);\n  } else {\n    // no utf8 transformation, do the array => string step.\n    result = utils.transformTo(\"string\", result);\n  }\n  if (!asUTF8 && !this.options.binary) {\n    result = utils.transformTo(\"string\", out.utf8encode(result));\n  }\n  return result;\n}\n/**\n * A simple object representing a file in the zip file.\n * @constructor\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data\n * @param {Object} options the options of the file\n */\nfunction ZipObject(name, data, options) {\n  this.name = name;\n  this.dir = options.dir;\n  this.date = options.date;\n  this.comment = options.comment;\n  this.unixPermissions = options.unixPermissions;\n  this.dosPermissions = options.dosPermissions;\n  this._data = data;\n  this.options = options;\n\n  /*\n   * This object contains initial values for dir and date.\n   * With them, we can check if the user changed the deprecated metadata in\n   * `ZipObject#options` or not.\n   */\n  this._initialMetadata = {\n    dir: options.dir,\n    date: options.date\n  };\n}\nZipObject.prototype = {\n  /**\n   * Return the content as UTF8 string.\n   * @return {string} the UTF8 string.\n   */\n  asText: function asText() {\n    return dataToString.call(this, true);\n  },\n  /**\n   * Returns the binary content.\n   * @return {string} the content as binary.\n   */\n  asBinary: function asBinary() {\n    return dataToString.call(this, false);\n  },\n  /**\n   * Returns the content as a nodejs Buffer.\n   * @return {Buffer} the content as a Buffer.\n   */\n  asNodeBuffer: function asNodeBuffer() {\n    var result = getBinaryData(this);\n    return utils.transformTo(\"nodebuffer\", result);\n  },\n  /**\n   * Returns the content as an Uint8Array.\n   * @return {Uint8Array} the content as an Uint8Array.\n   */\n  asUint8Array: function asUint8Array() {\n    var result = getBinaryData(this);\n    return utils.transformTo(\"uint8array\", result);\n  },\n  /**\n   * Returns the content as an ArrayBuffer.\n   * @return {ArrayBuffer} the content as an ArrayBufer.\n   */\n  asArrayBuffer: function asArrayBuffer() {\n    return this.asUint8Array().buffer;\n  }\n};\n\n/**\n * Transform an integer into a string in hexadecimal.\n * @private\n * @param {number} dec the number to convert.\n * @param {number} bytes the number of bytes to generate.\n * @returns {string} the result.\n */\nfunction decToHex(dec, bytes) {\n  var hex = \"\",\n    i;\n  for (i = 0; i < bytes; i++) {\n    hex += String.fromCharCode(dec & 0xff);\n    dec >>>= 8;\n  }\n  return hex;\n}\n\n/**\n * Transforms the (incomplete) options from the user into the complete\n * set of options to create a file.\n * @private\n * @param {Object} o the options from the user.\n * @return {Object} the complete set of options.\n */\nfunction prepareFileAttrs(o) {\n  o = o || {};\n  if (o.base64 === true && (o.binary === null || o.binary === undefined)) {\n    o.binary = true;\n  }\n  o = utils.extend(o, defaults);\n  o.date = o.date || new Date();\n  if (o.compression !== null) {\n    o.compression = o.compression.toUpperCase();\n  }\n  return o;\n}\n\n/**\n * Add a file in the current folder.\n * @private\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file\n * @param {Object} o the options of the file\n * @return {Object} the new file.\n */\nfunction fileAdd(name, data, o) {\n  // be sure sub folders exist\n  var dataType = utils.getTypeOf(data),\n    parent;\n  o = prepareFileAttrs(o);\n  if (typeof o.unixPermissions === \"string\") {\n    o.unixPermissions = parseInt(o.unixPermissions, 8);\n  }\n\n  // UNX_IFDIR  0040000 see zipinfo.c\n  if (o.unixPermissions && o.unixPermissions & 0x4000) {\n    o.dir = true;\n  }\n  // Bit 4    Directory\n  if (o.dosPermissions && o.dosPermissions & 0x0010) {\n    o.dir = true;\n  }\n  if (o.dir) {\n    name = forceTrailingSlash(name);\n  }\n  if (o.createFolders && (parent = parentFolder(name))) {\n    folderAdd.call(this, parent, true);\n  }\n  if (o.dir || data === null || typeof data === \"undefined\") {\n    o.base64 = false;\n    o.binary = false;\n    data = null;\n    dataType = null;\n  } else if (dataType === \"string\") {\n    if (o.binary && !o.base64) {\n      // optimizedBinaryString == true means that the file has already been filtered with a 0xFF mask\n      if (o.optimizedBinaryString !== true) {\n        // this is a string, not in a base64 format.\n        // Be sure that this is a correct \"binary string\"\n        data = utils.string2binary(data);\n      }\n    }\n  } else {\n    // arraybuffer, uint8array, ...\n    o.base64 = false;\n    o.binary = true;\n    if (!dataType && !(data instanceof CompressedObject)) {\n      throw new Error(\"The data of '\" + name + \"' is in an unsupported format !\");\n    }\n\n    // special case : it's way easier to work with Uint8Array than with ArrayBuffer\n    if (dataType === \"arraybuffer\") {\n      data = utils.transformTo(\"uint8array\", data);\n    }\n  }\n  var object = new ZipObject(name, data, o);\n  this.files[name] = object;\n  return object;\n}\n\n/**\n * Find the parent folder of the path.\n * @private\n * @param {string} path the path to use\n * @return {string} the parent folder, or \"\"\n */\nfunction parentFolder(path) {\n  if (path.slice(-1) === \"/\") {\n    path = path.substring(0, path.length - 1);\n  }\n  var lastSlash = path.lastIndexOf(\"/\");\n  return lastSlash > 0 ? path.substring(0, lastSlash) : \"\";\n}\n\n/**\n * Returns the path with a slash at the end.\n * @private\n * @param {String} path the path to check.\n * @return {String} the path with a trailing slash.\n */\nfunction forceTrailingSlash(path) {\n  // Check the name ends with a /\n  if (path.slice(-1) !== \"/\") {\n    path += \"/\"; // IE doesn't like substr(-1)\n  }\n  return path;\n}\n/**\n * Add a (sub) folder in the current folder.\n * @private\n * @param {string} name the folder's name\n * @param {boolean=} [createFolders] If true, automatically create sub\n *  folders. Defaults to false.\n * @return {Object} the new folder.\n */\nfunction folderAdd(name, createFolders) {\n  createFolders = typeof createFolders !== \"undefined\" ? createFolders : false;\n  name = forceTrailingSlash(name);\n\n  // Does this folder already exist?\n  if (!this.files[name]) {\n    fileAdd.call(this, name, null, {\n      dir: true,\n      createFolders: createFolders\n    });\n  }\n  return this.files[name];\n}\n\n/**\n * Generate a PizZip.CompressedObject for a given zipOject.\n * @param {ZipObject} file the object to read.\n * @param {PizZip.compression} compression the compression to use.\n * @param {Object} compressionOptions the options to use when compressing.\n * @return {PizZip.CompressedObject} the compressed result.\n */\nfunction generateCompressedObjectFrom(file, compression, compressionOptions) {\n  var result = new CompressedObject();\n  var content;\n\n  // the data has not been decompressed, we might reuse things !\n  if (file._data instanceof CompressedObject) {\n    result.uncompressedSize = file._data.uncompressedSize;\n    result.crc32 = file._data.crc32;\n    if (result.uncompressedSize === 0 || file.dir) {\n      compression = compressions.STORE;\n      result.compressedContent = \"\";\n      result.crc32 = 0;\n    } else if (file._data.compressionMethod === compression.magic) {\n      result.compressedContent = file._data.getCompressedContent();\n    } else {\n      content = file._data.getContent();\n      // need to decompress / recompress\n      result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions);\n    }\n  } else {\n    // have uncompressed data\n    content = getBinaryData(file);\n    if (!content || content.length === 0 || file.dir) {\n      compression = compressions.STORE;\n      content = \"\";\n    }\n    result.uncompressedSize = content.length;\n    result.crc32 = _crc(content);\n    result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions);\n  }\n  result.compressedSize = result.compressedContent.length;\n  result.compressionMethod = compression.magic;\n  return result;\n}\n\n/**\n * Generate the UNIX part of the external file attributes.\n * @param {Object} unixPermissions the unix permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :\n *\n * TTTTsstrwxrwxrwx0000000000ADVSHR\n * ^^^^____________________________ file type, see zipinfo.c (UNX_*)\n *     ^^^_________________________ setuid, setgid, sticky\n *        ^^^^^^^^^________________ permissions\n *                 ^^^^^^^^^^______ not used ?\n *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only\n */\nfunction generateUnixExternalFileAttr(unixPermissions, isDir) {\n  var result = unixPermissions;\n  if (!unixPermissions) {\n    // I can't use octal values in strict mode, hence the hexa.\n    //  040775 => 0x41fd\n    // 0100664 => 0x81b4\n    result = isDir ? 0x41fd : 0x81b4;\n  }\n  return (result & 0xffff) << 16;\n}\n\n/**\n * Generate the DOS part of the external file attributes.\n * @param {Object} dosPermissions the dos permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * Bit 0     Read-Only\n * Bit 1     Hidden\n * Bit 2     System\n * Bit 3     Volume Label\n * Bit 4     Directory\n * Bit 5     Archive\n */\nfunction generateDosExternalFileAttr(dosPermissions) {\n  // the dir flag is already set for compatibility\n\n  return (dosPermissions || 0) & 0x3f;\n}\n\n/**\n * Generate the various parts used in the construction of the final zip file.\n * @param {string} name the file name.\n * @param {ZipObject} file the file content.\n * @param {PizZip.CompressedObject} compressedObject the compressed object.\n * @param {number} offset the current offset from the start of the zip file.\n * @param {String} platform let's pretend we are this platform (change platform dependents fields)\n * @param {Function} encodeFileName the function to encode the file name / comment.\n * @return {object} the zip parts.\n */\nfunction generateZipParts(name, file, compressedObject, offset, platform, encodeFileName) {\n  var useCustomEncoding = encodeFileName !== utf8.utf8encode,\n    encodedFileName = utils.transformTo(\"string\", encodeFileName(file.name)),\n    utfEncodedFileName = utils.transformTo(\"string\", utf8.utf8encode(file.name)),\n    comment = file.comment || \"\",\n    encodedComment = utils.transformTo(\"string\", encodeFileName(comment)),\n    utfEncodedComment = utils.transformTo(\"string\", utf8.utf8encode(comment)),\n    useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,\n    useUTF8ForComment = utfEncodedComment.length !== comment.length,\n    o = file.options;\n  var dosTime,\n    dosDate,\n    extraFields = \"\",\n    unicodePathExtraField = \"\",\n    unicodeCommentExtraField = \"\",\n    dir,\n    date;\n\n  // handle the deprecated options.dir\n  if (file._initialMetadata.dir !== file.dir) {\n    dir = file.dir;\n  } else {\n    dir = o.dir;\n  }\n\n  // handle the deprecated options.date\n  if (file._initialMetadata.date !== file.date) {\n    date = file.date;\n  } else {\n    date = o.date;\n  }\n  var extFileAttr = 0;\n  var versionMadeBy = 0;\n  if (dir) {\n    // dos or unix, we set the dos dir flag\n    extFileAttr |= 0x00010;\n  }\n  if (platform === \"UNIX\") {\n    versionMadeBy = 0x031e; // UNIX, version 3.0\n    extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);\n  } else {\n    // DOS or other, fallback to DOS\n    versionMadeBy = 0x0014; // DOS, version 2.0\n    extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);\n  }\n\n  // date\n  // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html\n  // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html\n  // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html\n\n  dosTime = date.getHours();\n  dosTime <<= 6;\n  dosTime |= date.getMinutes();\n  dosTime <<= 5;\n  dosTime |= date.getSeconds() / 2;\n  dosDate = date.getFullYear() - 1980;\n  dosDate <<= 4;\n  dosDate |= date.getMonth() + 1;\n  dosDate <<= 5;\n  dosDate |= date.getDate();\n  if (useUTF8ForFileName) {\n    // set the unicode path extra field. unzip needs at least one extra\n    // field to correctly handle unicode path, so using the path is as good\n    // as any other information. This could improve the situation with\n    // other archive managers too.\n    // This field is usually used without the utf8 flag, with a non\n    // unicode path in the header (winrar, winzip). This helps (a bit)\n    // with the messy Windows' default compressed folders feature but\n    // breaks on p7zip which doesn't seek the unicode path extra field.\n    // So for now, UTF-8 everywhere !\n    unicodePathExtraField =\n    // Version\n    decToHex(1, 1) +\n    // NameCRC32\n    decToHex(_crc(encodedFileName), 4) +\n    // UnicodeName\n    utfEncodedFileName;\n    extraFields +=\n    // Info-ZIP Unicode Path Extra Field\n    \"\\x75\\x70\" +\n    // size\n    decToHex(unicodePathExtraField.length, 2) +\n    // content\n    unicodePathExtraField;\n  }\n  if (useUTF8ForComment) {\n    unicodeCommentExtraField =\n    // Version\n    decToHex(1, 1) +\n    // CommentCRC32\n    decToHex(this.crc32(encodedComment), 4) +\n    // UnicodeName\n    utfEncodedComment;\n    extraFields +=\n    // Info-ZIP Unicode Path Extra Field\n    \"\\x75\\x63\" +\n    // size\n    decToHex(unicodeCommentExtraField.length, 2) +\n    // content\n    unicodeCommentExtraField;\n  }\n  var header = \"\";\n\n  // version needed to extract\n  header += \"\\x0A\\x00\";\n  // general purpose bit flag\n  // set bit 11 if utf8\n  header += !useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment) ? \"\\x00\\x08\" : \"\\x00\\x00\";\n  // compression method\n  header += compressedObject.compressionMethod;\n  // last mod file time\n  header += decToHex(dosTime, 2);\n  // last mod file date\n  header += decToHex(dosDate, 2);\n  // crc-32\n  header += decToHex(compressedObject.crc32, 4);\n  // compressed size\n  header += decToHex(compressedObject.compressedSize, 4);\n  // uncompressed size\n  header += decToHex(compressedObject.uncompressedSize, 4);\n  // file name length\n  header += decToHex(encodedFileName.length, 2);\n  // extra field length\n  header += decToHex(extraFields.length, 2);\n  var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;\n  var dirRecord = signature.CENTRAL_FILE_HEADER +\n  // version made by (00: DOS)\n  decToHex(versionMadeBy, 2) +\n  // file header (common to file and central directory)\n  header +\n  // file comment length\n  decToHex(encodedComment.length, 2) +\n  // disk number start\n  \"\\x00\\x00\" +\n  // internal file attributes\n  \"\\x00\\x00\" +\n  // external file attributes\n  decToHex(extFileAttr, 4) +\n  // relative offset of local header\n  decToHex(offset, 4) +\n  // file name\n  encodedFileName +\n  // extra field\n  extraFields +\n  // file comment\n  encodedComment;\n  return {\n    fileRecord: fileRecord,\n    dirRecord: dirRecord,\n    compressedObject: compressedObject\n  };\n}\nmodule.exports = out;","map":{"version":3,"names":["_createForOfIteratorHelper","r","e","t","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","_n","F","s","n","done","value","f","TypeError","o","a","u","call","next","_arrayLikeToArray","toString","slice","constructor","name","from","test","support","require","utils","_crc","signature","defaults","base64","compressions","CompressedObject","nodeBuffer","utf8","StringWriter","Uint8ArrayWriter","getRawData","file","_data","getContent","options","binary","getTypeOf","copy","Uint8Array","set","getBinaryData","result","type","nodebuffer","asBinary","out","load","Error","filter","search","filename","relativePath","fileClone","files","hasOwnProperty","ZipObject","extend","root","push","data","arguments","isRegExp","regexp","dir","fileAdd","folder","arg","newFolder","folderAdd","ret","shallowClone","remove","kids","i","generate","compression","compressionOptions","platform","comment","mimeType","encodeFileName","utf8encode","checkSupport","zipData","encodedComment","transformTo","localDirLength","centralDirLength","writer","fileNames","fileOrder","indexOf","_iterator","_step","_name","compressionName","toUpperCase","compressedObject","generateCompressedObjectFrom","zipPart","generateZipParts","fileRecord","compressedSize","dirRecord","err","dirEnd","CENTRAL_DIRECTORY_END","decToHex","typeName","toLowerCase","append","compressedContent","zip","finalize","arrayBuffer2Blob","encode","crc32","input","crc","string","utf8decode","dataToString","asUTF8","decode","date","unixPermissions","dosPermissions","_initialMetadata","prototype","asText","asNodeBuffer","asUint8Array","asArrayBuffer","buffer","dec","bytes","hex","String","fromCharCode","prepareFileAttrs","undefined","Date","dataType","parent","parseInt","forceTrailingSlash","createFolders","parentFolder","optimizedBinaryString","string2binary","object","path","substring","lastSlash","lastIndexOf","content","uncompressedSize","STORE","compressionMethod","magic","getCompressedContent","compress","compressInputType","generateUnixExternalFileAttr","isDir","generateDosExternalFileAttr","offset","useCustomEncoding","encodedFileName","utfEncodedFileName","utfEncodedComment","useUTF8ForFileName","useUTF8ForComment","dosTime","dosDate","extraFields","unicodePathExtraField","unicodeCommentExtraField","extFileAttr","versionMadeBy","getHours","getMinutes","getSeconds","getFullYear","getMonth","getDate","header","LOCAL_FILE_HEADER","CENTRAL_FILE_HEADER","module","exports"],"sources":["/home/ali/Desktop/applications/node_modules/pizzip/js/object.js"],"sourcesContent":["\"use strict\";\n\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nvar support = require(\"./support.js\");\nvar utils = require(\"./utils.js\");\nvar _crc = require(\"./crc32.js\");\nvar signature = require(\"./signature.js\");\nvar defaults = require(\"./defaults.js\");\nvar base64 = require(\"./base64.js\");\nvar compressions = require(\"./compressions.js\");\nvar CompressedObject = require(\"./compressedObject.js\");\nvar nodeBuffer = require(\"./nodeBuffer.js\");\nvar utf8 = require(\"./utf8.js\");\nvar StringWriter = require(\"./stringWriter.js\");\nvar Uint8ArrayWriter = require(\"./uint8ArrayWriter.js\");\n\n/**\n * Returns the raw data of a ZipObject, decompress the content if necessary.\n * @param {ZipObject} file the file to use.\n * @return {String|ArrayBuffer|Uint8Array|Buffer} the data.\n */\nfunction getRawData(file) {\n  if (file._data instanceof CompressedObject) {\n    file._data = file._data.getContent();\n    file.options.binary = true;\n    file.options.base64 = false;\n    if (utils.getTypeOf(file._data) === \"uint8array\") {\n      var copy = file._data;\n      // when reading an arraybuffer, the CompressedObject mechanism will keep it and subarray() a Uint8Array.\n      // if we request a file in the same format, we might get the same Uint8Array or its ArrayBuffer (the original zip file).\n      file._data = new Uint8Array(copy.length);\n      // with an empty Uint8Array, Opera fails with a \"Offset larger than array size\"\n      if (copy.length !== 0) {\n        file._data.set(copy, 0);\n      }\n    }\n  }\n  return file._data;\n}\n\n/**\n * Returns the data of a ZipObject in a binary form. If the content is an unicode string, encode it.\n * @param {ZipObject} file the file to use.\n * @return {String|ArrayBuffer|Uint8Array|Buffer} the data.\n */\nfunction getBinaryData(file) {\n  var result = getRawData(file),\n    type = utils.getTypeOf(result);\n  if (type === \"string\") {\n    if (!file.options.binary) {\n      // unicode text !\n      // unicode string => binary string is a painful process, check if we can avoid it.\n      if (support.nodebuffer) {\n        return nodeBuffer(result, \"utf-8\");\n      }\n    }\n    return file.asBinary();\n  }\n  return result;\n}\n\n// return the actual prototype of PizZip\nvar out = {\n  /**\n   * Read an existing zip and merge the data in the current PizZip object.\n   * The implementation is in pizzip-load.js, don't forget to include it.\n   * @param {String|ArrayBuffer|Uint8Array|Buffer} stream  The stream to load\n   * @param {Object} options Options for loading the stream.\n   *  options.base64 : is the stream in base64 ? default : false\n   * @return {PizZip} the current PizZip object\n   */\n  load: function load() {\n    throw new Error(\"Load method is not defined. Is the file pizzip-load.js included ?\");\n  },\n  /**\n   * Filter nested files/folders with the specified function.\n   * @param {Function} search the predicate to use :\n   * function (relativePath, file) {...}\n   * It takes 2 arguments : the relative path and the file.\n   * @return {Array} An array of matching elements.\n   */\n  filter: function filter(search) {\n    var result = [];\n    var filename, relativePath, file, fileClone;\n    for (filename in this.files) {\n      if (!this.files.hasOwnProperty(filename)) {\n        continue;\n      }\n      file = this.files[filename];\n      // return a new object, don't let the user mess with our internal objects :)\n      fileClone = new ZipObject(file.name, file._data, utils.extend(file.options));\n      relativePath = filename.slice(this.root.length, filename.length);\n      if (filename.slice(0, this.root.length) === this.root &&\n      // the file is in the current root\n      search(relativePath, fileClone)) {\n        // and the file matches the function\n        result.push(fileClone);\n      }\n    }\n    return result;\n  },\n  /**\n   * Add a file to the zip file, or search a file.\n   * @param   {string|RegExp} name The name of the file to add (if data is defined),\n   * the name of the file to find (if no data) or a regex to match files.\n   * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded\n   * @param   {Object} o     File options\n   * @return  {PizZip|Object|Array} this PizZip object (when adding a file),\n   * a file (when searching by string) or an array of files (when searching by regex).\n   */\n  file: function file(name, data, o) {\n    if (arguments.length === 1) {\n      if (utils.isRegExp(name)) {\n        var regexp = name;\n        return this.filter(function (relativePath, file) {\n          return !file.dir && regexp.test(relativePath);\n        });\n      }\n      // text\n      return this.filter(function (relativePath, file) {\n        return !file.dir && relativePath === name;\n      })[0] || null;\n    }\n    // more than one argument : we have data !\n    name = this.root + name;\n    fileAdd.call(this, name, data, o);\n    return this;\n  },\n  /**\n   * Add a directory to the zip file, or search.\n   * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.\n   * @return  {PizZip} an object with the new directory as the root, or an array containing matching folders.\n   */\n  folder: function folder(arg) {\n    if (!arg) {\n      return this;\n    }\n    if (utils.isRegExp(arg)) {\n      return this.filter(function (relativePath, file) {\n        return file.dir && arg.test(relativePath);\n      });\n    }\n\n    // else, name is a new folder\n    var name = this.root + arg;\n    var newFolder = folderAdd.call(this, name);\n\n    // Allow chaining by returning a new object with this folder as the root\n    var ret = this.shallowClone();\n    ret.root = newFolder.name;\n    return ret;\n  },\n  /**\n   * Delete a file, or a directory and all sub-files, from the zip\n   * @param {string} name the name of the file to delete\n   * @return {PizZip} this PizZip object\n   */\n  remove: function remove(name) {\n    name = this.root + name;\n    var file = this.files[name];\n    if (!file) {\n      // Look for any folders\n      if (name.slice(-1) !== \"/\") {\n        name += \"/\";\n      }\n      file = this.files[name];\n    }\n    if (file && !file.dir) {\n      // file\n      delete this.files[name];\n    } else {\n      // maybe a folder, delete recursively\n      var kids = this.filter(function (relativePath, file) {\n        return file.name.slice(0, name.length) === name;\n      });\n      for (var i = 0; i < kids.length; i++) {\n        delete this.files[kids[i].name];\n      }\n    }\n    return this;\n  },\n  /**\n   * Generate the complete zip file\n   * @param {Object} options the options to generate the zip file :\n   * - base64, (deprecated, use type instead) true to generate base64.\n   * - compression, \"STORE\" by default.\n   * - type, \"base64\" by default. Values are : string, base64, uint8array, arraybuffer, blob.\n   * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file\n   */\n  generate: function generate(options) {\n    options = utils.extend(options || {}, {\n      base64: true,\n      compression: \"STORE\",\n      compressionOptions: null,\n      type: \"base64\",\n      platform: \"DOS\",\n      comment: null,\n      mimeType: \"application/zip\",\n      encodeFileName: utf8.utf8encode\n    });\n    utils.checkSupport(options.type);\n\n    // accept nodejs `process.platform`\n    if (options.platform === \"darwin\" || options.platform === \"freebsd\" || options.platform === \"linux\" || options.platform === \"sunos\") {\n      options.platform = \"UNIX\";\n    }\n    if (options.platform === \"win32\") {\n      options.platform = \"DOS\";\n    }\n    var zipData = [],\n      encodedComment = utils.transformTo(\"string\", options.encodeFileName(options.comment || this.comment || \"\"));\n    var localDirLength = 0,\n      centralDirLength = 0,\n      writer,\n      i;\n    var fileNames = [];\n    if (options.fileOrder instanceof Array) {\n      fileNames = options.fileOrder;\n    }\n    for (var name in this.files) {\n      if (fileNames.indexOf(name) === -1) {\n        fileNames.push(name);\n      }\n    }\n    if (typeof options.fileOrder === \"function\") {\n      fileNames = options.fileOrder(this.files);\n    }\n\n    // first, generate all the zip parts.\n    var _iterator = _createForOfIteratorHelper(fileNames),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _name = _step.value;\n        if (!this.files.hasOwnProperty(_name)) {\n          continue;\n        }\n        var file = this.files[_name];\n        var compressionName = file.options.compression || options.compression.toUpperCase();\n        var compression = compressions[compressionName];\n        if (!compression) {\n          throw new Error(compressionName + \" is not a valid compression method !\");\n        }\n        var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};\n        var compressedObject = generateCompressedObjectFrom.call(this, file, compression, compressionOptions);\n        var zipPart = generateZipParts.call(this, _name, file, compressedObject, localDirLength, options.platform, options.encodeFileName);\n        localDirLength += zipPart.fileRecord.length + compressedObject.compressedSize;\n        centralDirLength += zipPart.dirRecord.length;\n        zipData.push(zipPart);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var dirEnd = \"\";\n\n    // end of central dir signature\n    dirEnd = signature.CENTRAL_DIRECTORY_END +\n    // number of this disk\n    \"\\x00\\x00\" +\n    // number of the disk with the start of the central directory\n    \"\\x00\\x00\" +\n    // total number of entries in the central directory on this disk\n    decToHex(zipData.length, 2) +\n    // total number of entries in the central directory\n    decToHex(zipData.length, 2) +\n    // size of the central directory   4 bytes\n    decToHex(centralDirLength, 4) +\n    // offset of start of central directory with respect to the starting disk number\n    decToHex(localDirLength, 4) +\n    // .ZIP file comment length\n    decToHex(encodedComment.length, 2) +\n    // .ZIP file comment\n    encodedComment;\n\n    // we have all the parts (and the total length)\n    // time to create a writer !\n    var typeName = options.type.toLowerCase();\n    if (typeName === \"uint8array\" || typeName === \"arraybuffer\" || typeName === \"blob\" || typeName === \"nodebuffer\") {\n      writer = new Uint8ArrayWriter(localDirLength + centralDirLength + dirEnd.length);\n    } else {\n      writer = new StringWriter(localDirLength + centralDirLength + dirEnd.length);\n    }\n    for (i = 0; i < zipData.length; i++) {\n      writer.append(zipData[i].fileRecord);\n      writer.append(zipData[i].compressedObject.compressedContent);\n    }\n    for (i = 0; i < zipData.length; i++) {\n      writer.append(zipData[i].dirRecord);\n    }\n    writer.append(dirEnd);\n    var zip = writer.finalize();\n    switch (options.type.toLowerCase()) {\n      // case \"zip is an Uint8Array\"\n      case \"uint8array\":\n      case \"arraybuffer\":\n      case \"nodebuffer\":\n        return utils.transformTo(options.type.toLowerCase(), zip);\n      case \"blob\":\n        return utils.arrayBuffer2Blob(utils.transformTo(\"arraybuffer\", zip), options.mimeType);\n      // case \"zip is a string\"\n      case \"base64\":\n        return options.base64 ? base64.encode(zip) : zip;\n      default:\n        // case \"string\" :\n        return zip;\n    }\n  },\n  /**\n   * @deprecated\n   * This method will be removed in a future version without replacement.\n   */\n  crc32: function crc32(input, crc) {\n    return _crc(input, crc);\n  },\n  /**\n   * @deprecated\n   * This method will be removed in a future version without replacement.\n   */\n  utf8encode: function utf8encode(string) {\n    return utils.transformTo(\"string\", utf8.utf8encode(string));\n  },\n  /**\n   * @deprecated\n   * This method will be removed in a future version without replacement.\n   */\n  utf8decode: function utf8decode(input) {\n    return utf8.utf8decode(input);\n  }\n};\n/**\n * Transform this._data into a string.\n * @param {function} filter a function String -> String, applied if not null on the result.\n * @return {String} the string representing this._data.\n */\nfunction dataToString(asUTF8) {\n  var result = getRawData(this);\n  if (result === null || typeof result === \"undefined\") {\n    return \"\";\n  }\n  // if the data is a base64 string, we decode it before checking the encoding !\n  if (this.options.base64) {\n    result = base64.decode(result);\n  }\n  if (asUTF8 && this.options.binary) {\n    // PizZip.prototype.utf8decode supports arrays as input\n    // skip to array => string step, utf8decode will do it.\n    result = out.utf8decode(result);\n  } else {\n    // no utf8 transformation, do the array => string step.\n    result = utils.transformTo(\"string\", result);\n  }\n  if (!asUTF8 && !this.options.binary) {\n    result = utils.transformTo(\"string\", out.utf8encode(result));\n  }\n  return result;\n}\n/**\n * A simple object representing a file in the zip file.\n * @constructor\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data\n * @param {Object} options the options of the file\n */\nfunction ZipObject(name, data, options) {\n  this.name = name;\n  this.dir = options.dir;\n  this.date = options.date;\n  this.comment = options.comment;\n  this.unixPermissions = options.unixPermissions;\n  this.dosPermissions = options.dosPermissions;\n  this._data = data;\n  this.options = options;\n\n  /*\n   * This object contains initial values for dir and date.\n   * With them, we can check if the user changed the deprecated metadata in\n   * `ZipObject#options` or not.\n   */\n  this._initialMetadata = {\n    dir: options.dir,\n    date: options.date\n  };\n}\nZipObject.prototype = {\n  /**\n   * Return the content as UTF8 string.\n   * @return {string} the UTF8 string.\n   */\n  asText: function asText() {\n    return dataToString.call(this, true);\n  },\n  /**\n   * Returns the binary content.\n   * @return {string} the content as binary.\n   */\n  asBinary: function asBinary() {\n    return dataToString.call(this, false);\n  },\n  /**\n   * Returns the content as a nodejs Buffer.\n   * @return {Buffer} the content as a Buffer.\n   */\n  asNodeBuffer: function asNodeBuffer() {\n    var result = getBinaryData(this);\n    return utils.transformTo(\"nodebuffer\", result);\n  },\n  /**\n   * Returns the content as an Uint8Array.\n   * @return {Uint8Array} the content as an Uint8Array.\n   */\n  asUint8Array: function asUint8Array() {\n    var result = getBinaryData(this);\n    return utils.transformTo(\"uint8array\", result);\n  },\n  /**\n   * Returns the content as an ArrayBuffer.\n   * @return {ArrayBuffer} the content as an ArrayBufer.\n   */\n  asArrayBuffer: function asArrayBuffer() {\n    return this.asUint8Array().buffer;\n  }\n};\n\n/**\n * Transform an integer into a string in hexadecimal.\n * @private\n * @param {number} dec the number to convert.\n * @param {number} bytes the number of bytes to generate.\n * @returns {string} the result.\n */\nfunction decToHex(dec, bytes) {\n  var hex = \"\",\n    i;\n  for (i = 0; i < bytes; i++) {\n    hex += String.fromCharCode(dec & 0xff);\n    dec >>>= 8;\n  }\n  return hex;\n}\n\n/**\n * Transforms the (incomplete) options from the user into the complete\n * set of options to create a file.\n * @private\n * @param {Object} o the options from the user.\n * @return {Object} the complete set of options.\n */\nfunction prepareFileAttrs(o) {\n  o = o || {};\n  if (o.base64 === true && (o.binary === null || o.binary === undefined)) {\n    o.binary = true;\n  }\n  o = utils.extend(o, defaults);\n  o.date = o.date || new Date();\n  if (o.compression !== null) {\n    o.compression = o.compression.toUpperCase();\n  }\n  return o;\n}\n\n/**\n * Add a file in the current folder.\n * @private\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file\n * @param {Object} o the options of the file\n * @return {Object} the new file.\n */\nfunction fileAdd(name, data, o) {\n  // be sure sub folders exist\n  var dataType = utils.getTypeOf(data),\n    parent;\n  o = prepareFileAttrs(o);\n  if (typeof o.unixPermissions === \"string\") {\n    o.unixPermissions = parseInt(o.unixPermissions, 8);\n  }\n\n  // UNX_IFDIR  0040000 see zipinfo.c\n  if (o.unixPermissions && o.unixPermissions & 0x4000) {\n    o.dir = true;\n  }\n  // Bit 4    Directory\n  if (o.dosPermissions && o.dosPermissions & 0x0010) {\n    o.dir = true;\n  }\n  if (o.dir) {\n    name = forceTrailingSlash(name);\n  }\n  if (o.createFolders && (parent = parentFolder(name))) {\n    folderAdd.call(this, parent, true);\n  }\n  if (o.dir || data === null || typeof data === \"undefined\") {\n    o.base64 = false;\n    o.binary = false;\n    data = null;\n    dataType = null;\n  } else if (dataType === \"string\") {\n    if (o.binary && !o.base64) {\n      // optimizedBinaryString == true means that the file has already been filtered with a 0xFF mask\n      if (o.optimizedBinaryString !== true) {\n        // this is a string, not in a base64 format.\n        // Be sure that this is a correct \"binary string\"\n        data = utils.string2binary(data);\n      }\n    }\n  } else {\n    // arraybuffer, uint8array, ...\n    o.base64 = false;\n    o.binary = true;\n    if (!dataType && !(data instanceof CompressedObject)) {\n      throw new Error(\"The data of '\" + name + \"' is in an unsupported format !\");\n    }\n\n    // special case : it's way easier to work with Uint8Array than with ArrayBuffer\n    if (dataType === \"arraybuffer\") {\n      data = utils.transformTo(\"uint8array\", data);\n    }\n  }\n  var object = new ZipObject(name, data, o);\n  this.files[name] = object;\n  return object;\n}\n\n/**\n * Find the parent folder of the path.\n * @private\n * @param {string} path the path to use\n * @return {string} the parent folder, or \"\"\n */\nfunction parentFolder(path) {\n  if (path.slice(-1) === \"/\") {\n    path = path.substring(0, path.length - 1);\n  }\n  var lastSlash = path.lastIndexOf(\"/\");\n  return lastSlash > 0 ? path.substring(0, lastSlash) : \"\";\n}\n\n/**\n * Returns the path with a slash at the end.\n * @private\n * @param {String} path the path to check.\n * @return {String} the path with a trailing slash.\n */\nfunction forceTrailingSlash(path) {\n  // Check the name ends with a /\n  if (path.slice(-1) !== \"/\") {\n    path += \"/\"; // IE doesn't like substr(-1)\n  }\n  return path;\n}\n/**\n * Add a (sub) folder in the current folder.\n * @private\n * @param {string} name the folder's name\n * @param {boolean=} [createFolders] If true, automatically create sub\n *  folders. Defaults to false.\n * @return {Object} the new folder.\n */\nfunction folderAdd(name, createFolders) {\n  createFolders = typeof createFolders !== \"undefined\" ? createFolders : false;\n  name = forceTrailingSlash(name);\n\n  // Does this folder already exist?\n  if (!this.files[name]) {\n    fileAdd.call(this, name, null, {\n      dir: true,\n      createFolders: createFolders\n    });\n  }\n  return this.files[name];\n}\n\n/**\n * Generate a PizZip.CompressedObject for a given zipOject.\n * @param {ZipObject} file the object to read.\n * @param {PizZip.compression} compression the compression to use.\n * @param {Object} compressionOptions the options to use when compressing.\n * @return {PizZip.CompressedObject} the compressed result.\n */\nfunction generateCompressedObjectFrom(file, compression, compressionOptions) {\n  var result = new CompressedObject();\n  var content;\n\n  // the data has not been decompressed, we might reuse things !\n  if (file._data instanceof CompressedObject) {\n    result.uncompressedSize = file._data.uncompressedSize;\n    result.crc32 = file._data.crc32;\n    if (result.uncompressedSize === 0 || file.dir) {\n      compression = compressions.STORE;\n      result.compressedContent = \"\";\n      result.crc32 = 0;\n    } else if (file._data.compressionMethod === compression.magic) {\n      result.compressedContent = file._data.getCompressedContent();\n    } else {\n      content = file._data.getContent();\n      // need to decompress / recompress\n      result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions);\n    }\n  } else {\n    // have uncompressed data\n    content = getBinaryData(file);\n    if (!content || content.length === 0 || file.dir) {\n      compression = compressions.STORE;\n      content = \"\";\n    }\n    result.uncompressedSize = content.length;\n    result.crc32 = _crc(content);\n    result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions);\n  }\n  result.compressedSize = result.compressedContent.length;\n  result.compressionMethod = compression.magic;\n  return result;\n}\n\n/**\n * Generate the UNIX part of the external file attributes.\n * @param {Object} unixPermissions the unix permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :\n *\n * TTTTsstrwxrwxrwx0000000000ADVSHR\n * ^^^^____________________________ file type, see zipinfo.c (UNX_*)\n *     ^^^_________________________ setuid, setgid, sticky\n *        ^^^^^^^^^________________ permissions\n *                 ^^^^^^^^^^______ not used ?\n *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only\n */\nfunction generateUnixExternalFileAttr(unixPermissions, isDir) {\n  var result = unixPermissions;\n  if (!unixPermissions) {\n    // I can't use octal values in strict mode, hence the hexa.\n    //  040775 => 0x41fd\n    // 0100664 => 0x81b4\n    result = isDir ? 0x41fd : 0x81b4;\n  }\n  return (result & 0xffff) << 16;\n}\n\n/**\n * Generate the DOS part of the external file attributes.\n * @param {Object} dosPermissions the dos permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * Bit 0     Read-Only\n * Bit 1     Hidden\n * Bit 2     System\n * Bit 3     Volume Label\n * Bit 4     Directory\n * Bit 5     Archive\n */\nfunction generateDosExternalFileAttr(dosPermissions) {\n  // the dir flag is already set for compatibility\n\n  return (dosPermissions || 0) & 0x3f;\n}\n\n/**\n * Generate the various parts used in the construction of the final zip file.\n * @param {string} name the file name.\n * @param {ZipObject} file the file content.\n * @param {PizZip.CompressedObject} compressedObject the compressed object.\n * @param {number} offset the current offset from the start of the zip file.\n * @param {String} platform let's pretend we are this platform (change platform dependents fields)\n * @param {Function} encodeFileName the function to encode the file name / comment.\n * @return {object} the zip parts.\n */\nfunction generateZipParts(name, file, compressedObject, offset, platform, encodeFileName) {\n  var useCustomEncoding = encodeFileName !== utf8.utf8encode,\n    encodedFileName = utils.transformTo(\"string\", encodeFileName(file.name)),\n    utfEncodedFileName = utils.transformTo(\"string\", utf8.utf8encode(file.name)),\n    comment = file.comment || \"\",\n    encodedComment = utils.transformTo(\"string\", encodeFileName(comment)),\n    utfEncodedComment = utils.transformTo(\"string\", utf8.utf8encode(comment)),\n    useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,\n    useUTF8ForComment = utfEncodedComment.length !== comment.length,\n    o = file.options;\n  var dosTime,\n    dosDate,\n    extraFields = \"\",\n    unicodePathExtraField = \"\",\n    unicodeCommentExtraField = \"\",\n    dir,\n    date;\n\n  // handle the deprecated options.dir\n  if (file._initialMetadata.dir !== file.dir) {\n    dir = file.dir;\n  } else {\n    dir = o.dir;\n  }\n\n  // handle the deprecated options.date\n  if (file._initialMetadata.date !== file.date) {\n    date = file.date;\n  } else {\n    date = o.date;\n  }\n  var extFileAttr = 0;\n  var versionMadeBy = 0;\n  if (dir) {\n    // dos or unix, we set the dos dir flag\n    extFileAttr |= 0x00010;\n  }\n  if (platform === \"UNIX\") {\n    versionMadeBy = 0x031e; // UNIX, version 3.0\n    extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);\n  } else {\n    // DOS or other, fallback to DOS\n    versionMadeBy = 0x0014; // DOS, version 2.0\n    extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);\n  }\n\n  // date\n  // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html\n  // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html\n  // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html\n\n  dosTime = date.getHours();\n  dosTime <<= 6;\n  dosTime |= date.getMinutes();\n  dosTime <<= 5;\n  dosTime |= date.getSeconds() / 2;\n  dosDate = date.getFullYear() - 1980;\n  dosDate <<= 4;\n  dosDate |= date.getMonth() + 1;\n  dosDate <<= 5;\n  dosDate |= date.getDate();\n  if (useUTF8ForFileName) {\n    // set the unicode path extra field. unzip needs at least one extra\n    // field to correctly handle unicode path, so using the path is as good\n    // as any other information. This could improve the situation with\n    // other archive managers too.\n    // This field is usually used without the utf8 flag, with a non\n    // unicode path in the header (winrar, winzip). This helps (a bit)\n    // with the messy Windows' default compressed folders feature but\n    // breaks on p7zip which doesn't seek the unicode path extra field.\n    // So for now, UTF-8 everywhere !\n    unicodePathExtraField =\n    // Version\n    decToHex(1, 1) +\n    // NameCRC32\n    decToHex(_crc(encodedFileName), 4) +\n    // UnicodeName\n    utfEncodedFileName;\n    extraFields +=\n    // Info-ZIP Unicode Path Extra Field\n    \"\\x75\\x70\" +\n    // size\n    decToHex(unicodePathExtraField.length, 2) +\n    // content\n    unicodePathExtraField;\n  }\n  if (useUTF8ForComment) {\n    unicodeCommentExtraField =\n    // Version\n    decToHex(1, 1) +\n    // CommentCRC32\n    decToHex(this.crc32(encodedComment), 4) +\n    // UnicodeName\n    utfEncodedComment;\n    extraFields +=\n    // Info-ZIP Unicode Path Extra Field\n    \"\\x75\\x63\" +\n    // size\n    decToHex(unicodeCommentExtraField.length, 2) +\n    // content\n    unicodeCommentExtraField;\n  }\n  var header = \"\";\n\n  // version needed to extract\n  header += \"\\x0A\\x00\";\n  // general purpose bit flag\n  // set bit 11 if utf8\n  header += !useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment) ? \"\\x00\\x08\" : \"\\x00\\x00\";\n  // compression method\n  header += compressedObject.compressionMethod;\n  // last mod file time\n  header += decToHex(dosTime, 2);\n  // last mod file date\n  header += decToHex(dosDate, 2);\n  // crc-32\n  header += decToHex(compressedObject.crc32, 4);\n  // compressed size\n  header += decToHex(compressedObject.compressedSize, 4);\n  // uncompressed size\n  header += decToHex(compressedObject.uncompressedSize, 4);\n  // file name length\n  header += decToHex(encodedFileName.length, 2);\n  // extra field length\n  header += decToHex(extraFields.length, 2);\n  var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;\n  var dirRecord = signature.CENTRAL_FILE_HEADER +\n  // version made by (00: DOS)\n  decToHex(versionMadeBy, 2) +\n  // file header (common to file and central directory)\n  header +\n  // file comment length\n  decToHex(encodedComment.length, 2) +\n  // disk number start\n  \"\\x00\\x00\" +\n  // internal file attributes\n  \"\\x00\\x00\" +\n  // external file attributes\n  decToHex(extFileAttr, 4) +\n  // relative offset of local header\n  decToHex(offset, 4) +\n  // file name\n  encodedFileName +\n  // extra field\n  extraFields +\n  // file comment\n  encodedComment;\n  return {\n    fileRecord: fileRecord,\n    dirRecord: dirRecord,\n    compressedObject: compressedObject\n  };\n}\nmodule.exports = out;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}